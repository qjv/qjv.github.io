<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Planner</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        .mode-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 3px solid #e2e8f0;
        }
        .mode-tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #718096;
            transition: all 0.2s;
            margin-bottom: -3px;
        }
        .mode-tab:hover { color: #4a5568; }
        .mode-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .mode-content { display: none; }
        .mode-content.active { display: block; }
        
        h1 { color: #333; margin-bottom: 10px; font-size: 28px; }
        .subtitle { color: #666; margin-bottom: 25px; font-size: 14px; }
        .controls { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
        .input-group { display: flex; gap: 10px; align-items: center; }
        input[type="text"], input[type="number"] { padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; }
        input[type="text"] { width: 300px; }
        input[type="number"] { width: 80px; }
        button {
            padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px;
            cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s;
        }
        button:hover { background: #5568d3; transform: translateY(-2px); }
        button:active { transform: translateY(0); }
        button.secondary { background: #48bb78; }
        button.secondary:hover { background: #38a169; }
        button.danger { background: #f56565; }
        button.danger:hover { background: #e53e3e; }
        input[type="file"] { display: none; }
        
        .marker-type-selector {
            display: flex; gap: 10px; padding: 15px; background: #f7fafc;
            border-radius: 8px; margin-bottom: 15px; flex-wrap: wrap;
        }
        .marker-type-btn {
            padding: 12px 20px; background: white; border: 3px solid #e2e8f0; border-radius: 8px;
            cursor: pointer; font-weight: 600; transition: all 0.2s; display: flex; align-items: center; gap: 8px;
        }
        .marker-type-btn:hover { border-color: #cbd5e0; transform: translateY(-2px); }
        .marker-type-btn.active { border-width: 4px; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2); }
        
        .marker-icon { width: 24px; height: 24px; }
        .marker-icon.dot { width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .marker-icon.dot.Waypoint { border-style: dashed; }
        
        .gw2-marker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .gw2-marker-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 10px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .gw2-marker-item:hover { border-color: #cbd5e0; transform: translateY(-2px); }
        .gw2-marker-item.active { border-color: #667eea; border-width: 3px; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2); }
        .gw2-marker-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .gw2-marker-name { font-size: 13px; font-weight: 600; }
        .gw2-required-input {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
        }
        .gw2-required-input label { color: #666; }
        .gw2-required-input input { width: 50px; padding: 3px 6px; font-size: 11px; }
        
        .options-panel {
            display: flex; gap: 15px; padding: 12px 15px; background: #faf5ff;
            border-radius: 8px; margin-bottom: 15px; flex-wrap: wrap; align-items: center; border: 2px solid #d6bcfa;
        }
        .option-group { display: flex; align-items: center; gap: 8px; }
        .option-group label { font-weight: 600; color: #553c9a; font-size: 14px; }
        input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        
        .endpoint-mode-selector {
            display: flex; gap: 10px; padding: 12px 15px; background: #fff5f5;
            border-radius: 8px; margin-bottom: 15px; align-items: center; border: 2px solid #feb2b2;
        }
        .endpoint-mode-selector label { font-weight: 600; color: #742a2a; margin-right: 10px; }
        .mode-option {
            padding: 8px 16px; background: white; border: 2px solid #e2e8f0; border-radius: 6px;
            cursor: pointer; font-weight: 600; transition: all 0.2s; font-size: 13px;
        }
        .mode-option:hover { border-color: #cbd5e0; }
        .mode-option.active { border-color: #f56565; background: #fff5f5; color: #c53030; }
        .mode-description { font-size: 12px; color: #744210; margin-left: auto; font-style: italic; }
        
        .main-content { display: grid; grid-template-columns: 1fr 450px; gap: 20px; margin-top: 20px; }
        @media (max-width: 1200px) { .main-content { grid-template-columns: 1fr; } }
        
        .canvas-container {
            position: relative; border: 3px solid #667eea; border-radius: 8px; overflow: hidden;
            background: #f7f7f7; min-height: 400px; display: flex; align-items: center; justify-content: center;
        }
        canvas { display: block; cursor: crosshair; }
        
        .marker {
            position: absolute; width: 28px; height: 28px; border-radius: 50%;
            cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transform: translate(-50%, -50%);
            display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;
            color: white; transition: all 0.2s; z-index: 10;
        }
        .marker img { width: 24px; height: 24px; pointer-events: none; }
        .marker:hover { transform: translate(-50%, -50%) scale(1.3); box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
        .marker.start { background: #48bb78; border: 3px solid white; }
        .marker.end { background: #f56565; border: 3px solid white; }
        .marker.Marker { background: #4299e1; border: 3px solid white; }
        .marker.Waypoint { background: #9f7aea; border: 3px dashed white; cursor: ns-resize; }
        .marker.gw2 { background: transparent; border: none; box-shadow: none; width: 32px; height: 32px; }
        
        .legend {
            margin-top: 20px; padding: 15px; background: #f7fafc; border-radius: 6px;
            display: flex; gap: 20px; flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 13px; }
        
        .results-panel { display: none; }
        .results-panel.active { display: block; }
        .results-header {
            background: #667eea; color: white; padding: 15px 20px; border-radius: 8px 8px 0 0;
            font-weight: 600; font-size: 16px; cursor: pointer; display: flex; justify-content: space-between;
            align-items: center; user-select: none;
        }
        .results-header:hover { background: #5568d3; }
        .toggle-icon { font-size: 20px; transition: transform 0.3s; }
        .toggle-icon.expanded { transform: rotate(180deg); }
        
        .results-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .results-content.expanded { max-height: 2000px; }
        
        .method-result {
            border: 2px solid #e2e8f0; border-top: none; padding: 15px; background: white;
            transition: all 0.2s; cursor: pointer; position: relative;
        }
        .method-result:hover {
            background: #ebf8ff; border-color: #4299e1; transform: translateX(5px);
            box-shadow: -3px 0 0 #4299e1;
        }
        .method-result:hover::before {
            content: 'üëÅÔ∏è Previewing route'; position: absolute; top: 10px; right: 15px;
            font-size: 11px; color: #4299e1; font-weight: 600;
        }
        .method-result:last-child { border-radius: 0 0 8px 8px; }
        .method-result.best { background: #f0fff4; border-color: #48bb78; border-width: 3px; }
        
        .method-name {
            font-weight: 700; color: #2d3748; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .method-name .badge {
            background: #48bb78; color: white; padding: 3px 8px; border-radius: 4px;
            font-size: 11px; font-weight: 600;
        }
        .method-distance { color: #667eea; font-weight: 600; font-size: 18px; margin-bottom: 8px; }
        .method-route { color: #4a5568; font-size: 13px; line-height: 1.6; word-break: break-word; }
        
        .placeholder { text-align: center; color: #999; padding: 40px; }
        .placeholder-icon { font-size: 64px; margin-bottom: 15px; }
        .computing { text-align: center; padding: 30px; color: #667eea; }
        .computing-spinner { font-size: 32px; animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        
        .reminder-note {
            background: #fef5e7;
            border-left: 4px solid #f39c12;
            padding: 12px;
            margin-top: 15px;
            border-radius: 4px;
            font-size: 13px;
            color: #7d6608;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Route Planner</h1>
        
        <div class="mode-tabs">
            <button class="mode-tab active" onclick="switchMode('tsp')">TSP Solver</button>
            <button class="mode-tab" onclick="switchMode('gw2')">GW2 Leveling</button>
        </div>
        
        <!-- TSP MODE -->
        <div id="tsp-mode" class="mode-content active">
            <p class="subtitle">Traveling Salesman Problem solver with waypoint discovery and teleportation mechanics.</p>
            
            <div class="controls">
                <div class="input-group">
                    <input type="text" id="imageUrl" placeholder="Enter image URL...">
                    <button onclick="loadImageFromUrl()">Load URL</button>
                </div>
                <label for="imageFile">
                    <button onclick="document.getElementById('imageFile').click()">Upload Image</button>
                </label>
                <input type="file" id="imageFile" accept="image/*" onchange="loadImageFromFile(event)">
                <button class="secondary" onclick="calculatePath()">Find Shortest Path</button>
                <button class="danger" onclick="clearAll()">Clear All</button>
            </div>
            
            <div class="marker-type-selector" id="tspMarkerSelector">
                <div class="marker-type-btn start active" onclick="selectMarkerType('start')">
                    <div class="marker-icon dot" style="background: #48bb78;"></div>
                    <span>Start Point</span>
                </div>
                <div class="marker-type-btn end" onclick="selectMarkerType('end')">
                    <div class="marker-icon dot" style="background: #f56565;"></div>
                    <span>End Points</span>
                </div>
                <div class="marker-type-btn Marker" onclick="selectMarkerType('Marker')">
                    <div class="marker-icon dot" style="background: #4299e1;"></div>
                    <span>Markers</span>
                </div>
                <div class="marker-type-btn Waypoint" onclick="selectMarkerType('Waypoint')">
                    <div class="marker-icon dot Waypoint" style="background: #9f7aea;"></div>
                    <span>Waypoint</span>
                </div>
            </div>
            
            <div class="options-panel">
                <div class="option-group">
                    <input type="checkbox" id="WaypointDiscovery" onchange="toggleWaypointDiscovery()">
                    <label for="WaypointDiscovery">Waypoint Discovery Mode</label>
                </div>
            </div>
            
            <div class="endpoint-mode-selector" id="endpointModeSelector" style="display: none;">
                <label>Multiple Endpoints Mode:</label>
                <div class="mode-option active" onclick="selectEndpointMode('or')">OR (any)</div>
                <div class="mode-option" onclick="selectEndpointMode('and')">AND (all)</div>
                <div class="mode-description" id="modeDescription">Choose best endpoint to finish</div>
            </div>
        </div>
        
        <!-- GW2 MODE -->
        <div id="gw2-mode" class="mode-content">
            <p class="subtitle">Plan optimal leveling routes with start/end points, waypoint teleportation, and required objectives. Set "Required" to 0 for optional markers.</p>
            
            <div class="controls">
                <div class="input-group">
                    <input type="text" id="imageUrlGW2" placeholder="Enter map image URL...">
                    <button onclick="loadImageFromUrlGW2()">Load URL</button>
                </div>
                <label for="imageFileGW2">
                    <button onclick="document.getElementById('imageFileGW2').click()">Upload Image</button>
                </label>
                <input type="file" id="imageFileGW2" accept="image/*" onchange="loadImageFromFileGW2(event)">
                <button class="secondary" onclick="calculatePath()">Find Best Route</button>
                <button class="danger" onclick="clearAll()">Clear All</button>
            </div>
            
            <div class="gw2-marker-grid" id="gw2MarkerSelector"></div>
            
            <div class="options-panel">
                <div class="option-group">
                    <input type="checkbox" id="WaypointDiscoveryGW2" onchange="toggleWaypointDiscoveryGW2()">
                    <label for="WaypointDiscoveryGW2">Waypoint Discovery Mode</label>
                </div>
            </div>
            
            <div class="reminder-note">
                ‚ö†Ô∏è <strong>TODO - Performance Optimization:</strong> Future improvements will include better subset selection (choosing optimal markers when requirements < available), faster algorithms for 20+ points, and parallel computation for multiple scenarios.
            </div>
        </div>
        
        <div class="main-content">
            <div>
                <div class="canvas-container" id="canvasContainer">
                    <div class="placeholder">
                        <div class="placeholder-icon">üìç</div>
                        <p>Load an image to get started</p>
                    </div>
                </div>
                
                <div class="legend" id="legend"></div>
            </div>
            
            <div class="results-panel" id="resultsPanel">
                <div class="results-header" onclick="toggleResults()">
                    <span>üìä Algorithm Comparison</span>
                    <span class="toggle-icon" id="toggleIcon">‚ñº</span>
                </div>
                <div class="results-content" id="resultsContent"></div>
            </div>
        </div>
    </div>

    <script>
        const GW2_MARKERS = [
            { type: 'start', name: 'Start', icon: null, color: '#48bb78', isSpecial: true },
            { type: 'end', name: 'End', icon: null, color: '#f56565', isSpecial: true },
            { type: 'waypoint', name: 'Waypoint', icon: 'https://wiki.guildwars2.com/images/d/d2/Waypoint_%28map_icon%29.png', color: '#4299e1' },
            { type: 'heart', name: 'Heart', icon: 'https://wiki.guildwars2.com/images/f/f8/Complete_heart_%28map_icon%29.png', color: '#f56565' },
            { type: 'scout', name: 'Scout', icon: 'https://wiki.guildwars2.com/images/f/fe/Scout_%28map_icon%29.png', color: '#48bb78' },
            { type: 'vista', name: 'Vista', icon: 'https://wiki.guildwars2.com/images/f/ff/Vista_%28map_icon%29.png', color: '#9f7aea' },
            { type: 'poi', name: 'Point of Interest', icon: 'https://wiki.guildwars2.com/images/7/70/Point_of_interest_%28map_icon%29.png', color: '#ed8936' },
            { type: 'dodge', name: 'Dodge', icon: 'https://wiki.guildwars2.com/images/c/cc/Dodge_Instructor.png', color: '#38b2ac' },
            { type: 'event', name: 'Possible Event', icon: 'https://wiki.guildwars2.com/images/b/bc/Event_star_%28map_icon%29.png', color: '#ecc94b' },
            { type: 'harvest', name: 'Harvest', icon: 'https://wiki.guildwars2.com/images/b/b2/Harvesting_Collection_Box_%28map_icon%29.png', color: '#68d391' },
            { type: 'mining', name: 'Mining', icon: 'https://wiki.guildwars2.com/images/7/79/Mining_Collection_Box_%28map_icon%29.png', color: '#a0aec0' },
            { type: 'logging', name: 'Logging', icon: 'https://wiki.guildwars2.com/images/d/d8/Logging_Collection_Box_%28map_icon%29.png', color: '#975a16' }
        ];
        
        let currentMode = 'tsp';
        let canvas, ctx;
        let img = null;
        let markers = {
            start: null,
            ends: [],
            Markers: [],
            Waypoints: [],
            gw2: {} // Will store arrays for each GW2 marker type
        };
        let gw2Requirements = {}; // Stores minimum required for each type
        let optimalRoute = [];
        let previewRoute = [];
        let allResults = [];
        let markerElements = [];
        let selectedMarkerType = 'start';
        let endpointMode = 'or';
        let WaypointDiscoveryMode = false;
        const TELEPORT_COST = 0; 
        
        let resizingWaypoint = null;
        let isDraggingRadius = false;
        
        // Initialize GW2 markers object and requirements
        GW2_MARKERS.forEach(m => {
            markers.gw2[m.type] = [];
            gw2Requirements[m.type] = 0;
        });
        
        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.mode-content').forEach(content => content.classList.remove('active'));
            
            if (mode === 'tsp') {
                document.querySelector('.mode-tab:nth-child(1)').classList.add('active');
                document.getElementById('tsp-mode').classList.add('active');
                selectedMarkerType = 'start';
                document.querySelectorAll('#tspMarkerSelector .marker-type-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector('#tspMarkerSelector .marker-type-btn.start').classList.add('active');
            } else {
                document.querySelector('.mode-tab:nth-child(2)').classList.add('active');
                document.getElementById('gw2-mode').classList.add('active');
                initGW2MarkerSelector();
                selectedMarkerType = 'waypoint';
            }
            updateLegend();
            clearAll();
        }
        
        function initGW2MarkerSelector() {
            const container = document.getElementById('gw2MarkerSelector');
            container.innerHTML = '';
            
            GW2_MARKERS.forEach(markerDef => {
                const item = document.createElement('div');
                item.className = 'gw2-marker-item';
                if (selectedMarkerType === markerDef.type) item.classList.add('active');
                item.onclick = () => selectGW2MarkerType(markerDef.type);
                
                let iconHtml = '';
                if (markerDef.icon) {
                    iconHtml = `<img class="marker-icon" src="${markerDef.icon}" alt="${markerDef.name}">`;
                } else {
                    iconHtml = `<div class="marker-icon dot" style="background: ${markerDef.color};"></div>`;
                }
                
                let requirementHtml = '';
                if (!markerDef.isSpecial) {
                    requirementHtml = `
                        <div class="gw2-required-input">
                            <label>Required:</label>
                            <input type="number" min="0" value="${gw2Requirements[markerDef.type]}" 
                                   onclick="event.stopPropagation()" 
                                   onchange="updateGW2Requirement('${markerDef.type}', this.value)">
                        </div>
                    `;
                }
                
                item.innerHTML = `
                    <div class="gw2-marker-header">
                        ${iconHtml}
                        <span class="gw2-marker-name">${markerDef.name}</span>
                    </div>
                    ${requirementHtml}
                `;
                
                container.appendChild(item);
            });
        }
        
        function selectGW2MarkerType(type) {
            selectedMarkerType = type;
            document.querySelectorAll('.gw2-marker-item').forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');
        }
        
        function updateGW2Requirement(type, value) {
            gw2Requirements[type] = parseInt(value) || 0;
        }
        
        function selectMarkerType(type) {
            selectedMarkerType = type;
            document.querySelectorAll('#tspMarkerSelector .marker-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`#tspMarkerSelector .marker-type-btn.${type}`).classList.add('active');
        }
        
        function toggleWaypointDiscovery() {
            WaypointDiscoveryMode = document.getElementById('WaypointDiscovery').checked;
            optimalRoute = [];
            previewRoute = [];
            allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            drawCanvas();
        }
        
        function toggleWaypointDiscoveryGW2() {
            WaypointDiscoveryMode = document.getElementById('WaypointDiscoveryGW2').checked;
            optimalRoute = [];
            previewRoute = [];
            allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            drawCanvas();
        }
        
        function selectEndpointMode(mode) {
            endpointMode = mode;
            document.querySelectorAll('.mode-option').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            const description = document.getElementById('modeDescription');
            if (mode === 'or') {
                description.textContent = 'Choose best endpoint to finish';
            } else {
                description.textContent = 'Visit all endpoints (Obligatory teleport after each)';
            }
        }
        
        function updateEndpointModeVisibility() {
            const selector = document.getElementById('endpointModeSelector');
            if (currentMode === 'tsp' && markers.ends.length > 1) {
                selector.style.display = 'flex';
            } else {
                selector.style.display = 'none';
            }
        }
        
        function toggleResults() {
            const content = document.getElementById('resultsContent');
            const icon = document.getElementById('toggleIcon');
            content.classList.toggle('expanded');
            icon.classList.toggle('expanded');
        }
        
        function loadImageFromUrl() {
            const url = document.getElementById('imageUrl').value.trim();
            if (!url) { alert('Please enter an image URL'); return; }
            loadImage(url);
        }
        
        function loadImageFromUrlGW2() {
            const url = document.getElementById('imageUrlGW2').value.trim();
            if (!url) { alert('Please enter an image URL'); return; }
            loadImage(url);
        }
        
        function loadImage(url) {
            const image = new Image();
            image.crossOrigin = "anonymous";
            image.onload = () => { img = image; initCanvas(); };
            image.onerror = () => { 
                // Try without CORS
                const image2 = new Image();
                image2.onload = () => { img = image2; initCanvas(); };
                image2.onerror = () => { alert('Failed to load image. Try uploading it instead.'); };
                image2.src = url;
            };
            image.src = url;
        }
        
        function loadImageFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => { img = image; initCanvas(); };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function loadImageFromFileGW2(event) {
            loadImageFromFile(event);
        }
        
        function initCanvas() {
            if (currentMode === 'tsp') {
                markers = { start: null, ends: [], Markers: [], Waypoints: [], gw2: markers.gw2, gw2Start: markers.gw2Start, gw2Ends: markers.gw2Ends };
            } else {
                const oldGw2 = markers.gw2;
                markers.gw2 = {};
                GW2_MARKERS.forEach(m => {
                    if (!m.isSpecial) markers.gw2[m.type] = [];
                });
                markers.gw2Start = null;
                markers.gw2Ends = [];
                gw2Waypoints = [];
            }
            
            optimalRoute = [];
            previewRoute = [];
            allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            updateEndpointModeVisibility();
            
            const container = document.getElementById('canvasContainer');
            container.innerHTML = '';
            markerElements = [];
            
            canvas = document.createElement('canvas');
            const maxWidth = container.clientWidth - 20;
            const maxHeight = 600;
            let width = img.width;
            let height = img.height;
            
            if (width > maxWidth) {
                height = (maxWidth / width) * height;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (maxHeight / height) * width;
                height = maxHeight;
            }
            
            canvas.width = width;
            canvas.height = height;
            ctx = canvas.getContext('2d');
            container.appendChild(canvas);
            drawCanvas();
            canvas.addEventListener('click', handleCanvasClick);
            updateLegend();
        }
        
        function updateLegend() {
            const legend = document.getElementById('legend');
            if (currentMode === 'tsp') {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="marker-icon dot" style="background: #48bb78;"></div>
                        <span>Start (required)</span>
                    </div>
                    <div class="legend-item">
                        <div class="marker-icon dot" style="background: #f56565;"></div>
                        <span>End</span>
                    </div>
                    <div class="legend-item">
                        <div class="marker-icon dot" style="background: #4299e1;"></div>
                        <span>Markers</span>
                    </div>
                    <div class="legend-item">
                        <div class="marker-icon dot Waypoint" style="background: #9f7aea;"></div>
                        <span>Waypoints (Drag to resize ‚Ä¢ ‚úì = discovered)</span>
                    </div>
                    <div class="legend-item" style="margin-left: auto; font-style: italic; color: #666;">
                        <span>üí° Hover over results to preview routes</span>
                    </div>
                `;
            } else {
                let html = '';
                
                // Start/End
                if (markers.gw2Start) {
                    html += `
                        <div class="legend-item">
                            <div class="marker-icon dot" style="background: #48bb78;"></div>
                            <span>Start: 1</span>
                        </div>
                    `;
                }
                if (markers.gw2Ends.length > 0) {
                    html += `
                        <div class="legend-item">
                            <div class="marker-icon dot" style="background: #f56565;"></div>
                            <span>End: ${markers.gw2Ends.length}</span>
                        </div>
                    `;
                }
                
                // Waypoints
                if (gw2Waypoints.length > 0) {
                    html += `
                        <div class="legend-item">
                            <img class="marker-icon" src="https://wiki.guildwars2.com/images/d/d2/Waypoint_%28map_icon%29.png" alt="Waypoint">
                            <span>Waypoints: ${gw2Waypoints.length}</span>
                        </div>
                    `;
                }
                
                // Other markers
                GW2_MARKERS.forEach(m => {
                    if (m.isSpecial) return;
                    if (m.type === 'waypoint') return; // Already handled
                    const count = markers.gw2[m.type] ? markers.gw2[m.type].length : 0;
                    if (count === 0 && gw2Requirements[m.type] === 0) return;
                    const required = gw2Requirements[m.type];
                    html += `
                        <div class="legend-item">
                            <img class="marker-icon" src="${m.icon}" alt="${m.name}">
                            <span>${m.name}: ${count}${required > 0 ? ` (req: ${required})` : ''}</span>
                        </div>
                    `;
                });
                legend.innerHTML = html;
            }
        }
        
        function drawCanvas() {
            if (!ctx || !img) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Draw waypoint discovery circles
            const waypointsToShow = currentMode === 'tsp' ? markers.Waypoints : gw2Waypoints;
            waypointsToShow.forEach(w => {
                ctx.strokeStyle = '#9f7aea';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(159, 122, 234, 0.1)';
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]);
            
            const routeToDraw = previewRoute.length > 0 ? previewRoute : optimalRoute;
            const isPreview = previewRoute.length > 0;
            
            if (WaypointDiscoveryMode && routeToDraw.length > 0) {
                const discoveredWaypoints = new Set();
                
                for (let i = 0; i < routeToDraw.length; i++) {
                    const point = routeToDraw[i];
                    updateDiscoveredWaypointsGeneric(point, discoveredWaypoints);
                    
                    if (i > 0) {
                        const prevPoint = routeToDraw[i - 1];
                        for (const Waypoint of waypointsToShow) {
                            if (!discoveredWaypoints.has(Waypoint) && 
                                lineSegmentIntersectsCircle(prevPoint, point, Waypoint, Waypoint.radius)) {
                                discoveredWaypoints.add(Waypoint);
                            }
                        }
                    }
                }
                
                for (const Waypoint of discoveredWaypoints) {
                    ctx.strokeStyle = '#48bb78';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(Waypoint.x, Waypoint.y, Waypoint.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#48bb78';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('‚úì', Waypoint.x + Waypoint.radius + 5, Waypoint.y - Waypoint.radius);
                }
                ctx.setLineDash([]);
            }
            
            if (routeToDraw.length > 0) {
                ctx.strokeStyle = isPreview ? '#4299e1' : '#f56565';
                ctx.lineWidth = isPreview ? 3 : 4;
                ctx.setLineDash(isPreview ? [4, 4] : [8, 8]);
                ctx.globalAlpha = isPreview ? 0.7 : 0.8;
                
                for (let i = 0; i < routeToDraw.length - 1; i++) {
                    const current = routeToDraw[i];
                    const next = routeToDraw[i + 1];
                    const isWaypointType = (currentMode === 'tsp' && next.type === 'Waypoint') || 
                                          (currentMode === 'gw2' && next.type === 'waypoint');
                    if (isWaypointType && !next.explicitVisit) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(next.x, next.y);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1.0;
                ctx.setLineDash([]);
                
                for (let i = 0; i < routeToDraw.length - 1; i++) {
                    const current = routeToDraw[i];
                    const next = routeToDraw[i + 1];
                    const isWaypointType = (currentMode === 'tsp' && next.type === 'Waypoint') || 
                                          (currentMode === 'gw2' && next.type === 'waypoint');
                    if (isWaypointType && !next.explicitVisit) {
                        const text = `‚ö° W${next.id + 1}`;
                        const textPos = findBestTextPosition(current, next, text, routeToDraw);
                        ctx.save();
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = isPreview ? '#4299e1' : '#9f7aea';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.strokeText(text, textPos.x, textPos.y);
                        ctx.fillText(text, textPos.x, textPos.y);
                        ctx.restore();
                    }
                }
            }
        }
        
        function findBestTextPosition(origin, Waypoint, text, route) {
            const dx = Waypoint.x - origin.x;
            const dy = Waypoint.y - origin.y;
            const angle = Math.atan2(dy, dx);
            const positions = [
                { offset: 35, angleOffset: 0 },
                { offset: 35, angleOffset: Math.PI / 2 },
                { offset: 35, angleOffset: -Math.PI / 2 },
                { offset: 35, angleOffset: Math.PI },
                { offset: 50, angleOffset: Math.PI / 4 },
                { offset: 50, angleOffset: -Math.PI / 4 },
                { offset: 50, angleOffset: 3 * Math.PI / 4 },
                { offset: 50, angleOffset: -3 * Math.PI / 4 },
            ];
            ctx.font = 'bold 14px Arial';
            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.width;
            const allMarkers = [markers.start, ...markers.ends, ...markers.Markers, ...markers.Waypoints, ...route].filter(m => m);
            
            for (const pos of positions) {
                const testAngle = angle + pos.angleOffset;
                const testX = origin.x + Math.cos(testAngle) * pos.offset;
                const testY = origin.y + Math.sin(testAngle) * pos.offset;
                let hasCollision = false;
                const markerRadius = 20;
                
                for (const marker of allMarkers) {
                    const dist = Math.sqrt(Math.pow(testX - marker.x, 2) + Math.pow(testY - marker.y, 2));
                    if (dist < markerRadius + textWidth / 2) { hasCollision = true; break; }
                }
                if (!hasCollision) return { x: testX, y: testY };
            }
            return { x: origin.x + Math.cos(angle) * 60, y: origin.y + Math.sin(angle) * 60 };
        }
        
        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentMode === 'tsp') {
                if (selectedMarkerType === 'start') {
                    if (markers.start) removeMarker('start', null);
                    markers.start = { x, y, type: 'start' };
                    createMarkerElement('start', x, y);
                } else if (selectedMarkerType === 'end') {
                    const id = markers.ends.length;
                    markers.ends.push({ x, y, id, type: 'end' });
                    createMarkerElement('end', x, y, id);
                    updateEndpointModeVisibility();
                } else if (selectedMarkerType === 'Marker') {
                    const id = markers.Markers.length;
                    markers.Markers.push({ x, y, id, type: 'Marker' });
                    createMarkerElement('Marker', x, y, id);
                } else if (selectedMarkerType === 'Waypoint') {
                    const id = markers.Waypoints.length;
                    markers.Waypoints.push({ x, y, id, type: 'Waypoint', radius: 30 });
                    createMarkerElement('Waypoint', x, y, id);
                    drawCanvas();
                }
            } else {
                // GW2 mode
                if (selectedMarkerType === 'start') {
                    if (markers.gw2Start) removeGW2Marker('start', null);
                    markers.gw2Start = { x, y, type: 'start' };
                    createGW2MarkerElement('start', x, y, null);
                } else if (selectedMarkerType === 'end') {
                    const id = markers.gw2Ends.length;
                    markers.gw2Ends.push({ x, y, id, type: 'end' });
                    createGW2MarkerElement('end', x, y, id);
                } else if (selectedMarkerType === 'waypoint') {
                    const id = gw2Waypoints.length;
                    gw2Waypoints.push({ x, y, id, type: 'waypoint', radius: 30 });
                    createGW2MarkerElement('waypoint', x, y, id, true);
                    drawCanvas();
                } else {
                    const markerType = selectedMarkerType;
                    const id = markers.gw2[markerType].length;
                    markers.gw2[markerType].push({ x, y, id, type: markerType });
                    createGW2MarkerElement(markerType, x, y, id);
                }
                updateLegend();
            }
        }
        
        function onWaypointResize(e) {
            if (!resizingWaypoint) return;
            isDraggingRadius = true;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const dist = Math.sqrt(Math.pow(mouseX - resizingWaypoint.x, 2) + Math.pow(mouseY - resizingWaypoint.y, 2));
            resizingWaypoint.radius = Math.max(15, dist);
            
            drawCanvas();
        }
        
        function onWaypointResizeEnd() {
            resizingWaypoint = null;
            document.removeEventListener('mousemove', onWaypointResize);
            document.removeEventListener('mouseup', onWaypointResizeEnd);
            setTimeout(() => { isDraggingRadius = false; }, 50);
        }

        function createMarkerElement(type, x, y, id = null) {
            const container = document.getElementById('canvasContainer');
            const rect = canvas.getBoundingClientRect();
            const marker = document.createElement('div');
            marker.className = `marker ${type}`;
            marker.style.left = (rect.left - container.getBoundingClientRect().left + x) + 'px';
            marker.style.top = (rect.top - container.getBoundingClientRect().top + y) + 'px';
            marker.dataset.type = type;
            
            if (type === 'Marker') { marker.dataset.id = id; marker.textContent = id + 1; }
            else if (type === 'Waypoint') { 
                marker.dataset.id = id; 
                marker.textContent = 'W' + (id + 1); 
                
                marker.addEventListener('mousedown', function(e) {
                    if (e.button !== 0) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizingWaypoint = markers.Waypoints.find(w => w.id === id);
                    isDraggingRadius = false;
                    
                    document.addEventListener('mousemove', onWaypointResize);
                    document.addEventListener('mouseup', onWaypointResizeEnd);
                });
            }
            else if (type === 'end') { marker.dataset.id = id; marker.textContent = 'E' + (id + 1); }
            
            marker.addEventListener('click', function(e) {
                e.stopPropagation();
                if (type === 'Waypoint' && isDraggingRadius) {
                    return;
                }
                removeMarker(type, id);
            });
            container.appendChild(marker);
            markerElements.push(marker);
        }
        
        function createGW2MarkerElement(type, x, y, id, isWaypoint = false) {
            const container = document.getElementById('canvasContainer');
            const rect = canvas.getBoundingClientRect();
            const marker = document.createElement('div');
            marker.className = `marker gw2`;
            if (type === 'waypoint' && isWaypoint) {
                marker.classList.add('Waypoint');
                marker.style.cursor = 'ns-resize';
            }
            marker.style.left = (rect.left - container.getBoundingClientRect().left + x) + 'px';
            marker.style.top = (rect.top - container.getBoundingClientRect().top + y) + 'px';
            marker.dataset.type = type;
            if (id !== null) marker.dataset.id = id;
            
            const markerDef = GW2_MARKERS.find(m => m.type === type);
            
            if (markerDef.icon) {
                const img = document.createElement('img');
                img.src = markerDef.icon;
                img.style.width = '28px';
                img.style.height = '28px';
                marker.appendChild(img);
            } else {
                // Special markers (start/end)
                marker.style.background = markerDef.color;
                marker.style.border = '3px solid white';
                marker.style.width = '28px';
                marker.style.height = '28px';
                marker.style.borderRadius = '50%';
                if (type === 'start') {
                    marker.textContent = 'S';
                } else if (type === 'end') {
                    marker.textContent = 'E' + (id + 1);
                }
            }
            
            // Add resize handler for waypoints
            if (type === 'waypoint' && isWaypoint) {
                marker.addEventListener('mousedown', function(e) {
                    if (e.button !== 0) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizingWaypoint = gw2Waypoints.find(w => w.id === id);
                    isDraggingRadius = false;
                    
                    document.addEventListener('mousemove', onWaypointResize);
                    document.addEventListener('mouseup', onWaypointResizeEnd);
                });
            }
            
            marker.addEventListener('click', function(e) {
                e.stopPropagation();
                if (type === 'waypoint' && isDraggingRadius) {
                    return;
                }
                removeGW2Marker(type, id);
            });
            
            container.appendChild(marker);
            markerElements.push(marker);
        }
        
        function removeMarker(type, id = null) {
            const container = document.getElementById('canvasContainer');
            if (type === 'start') {
                markers.start = null;
                const element = container.querySelector('.marker.start');
                if (element) element.remove();
            } else if (type === 'end') {
                const idx = markers.ends.findIndex(e => e.id === id);
                if (idx !== -1) {
                    markers.ends.splice(idx, 1);
                    container.querySelectorAll('.marker.end').forEach(el => el.remove());
                    markers.ends.forEach((e, i) => { e.id = i; createMarkerElement('end', e.x, e.y, i); });
                }
                updateEndpointModeVisibility();
            } else if (type === 'Marker') {
                const idx = markers.Markers.findIndex(w => w.id === id);
                if (idx !== -1) {
                    markers.Markers.splice(idx, 1);
                    container.querySelectorAll('.marker.Marker').forEach(el => el.remove());
                    markers.Markers.forEach((w, i) => { w.id = i; createMarkerElement('Marker', w.x, w.y, i); });
                }
            } else if (type === 'Waypoint') {
                const idx = markers.Waypoints.findIndex(w => w.id === id);
                if (idx !== -1) {
                    markers.Waypoints.splice(idx, 1);
                    container.querySelectorAll('.marker.Waypoint').forEach(el => el.remove());
                    markers.Waypoints.forEach((w, i) => { w.id = i; createMarkerElement('Waypoint', w.x, w.y, i); });
                }
            }
            optimalRoute = []; previewRoute = []; allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            drawCanvas();
        }
        
        function removeGW2Marker(type, id) {
            const container = document.getElementById('canvasContainer');
            
            if (type === 'start') {
                markers.gw2Start = null;
                const element = container.querySelector('.marker.gw2[data-type="start"]');
                if (element) element.remove();
            } else if (type === 'end') {
                const idx = markers.gw2Ends.findIndex(e => e.id === id);
                if (idx !== -1) {
                    markers.gw2Ends.splice(idx, 1);
                    container.querySelectorAll('.marker.gw2[data-type="end"]').forEach(el => el.remove());
                    markers.gw2Ends.forEach((e, i) => { e.id = i; createGW2MarkerElement('end', e.x, e.y, i); });
                }
            } else if (type === 'waypoint') {
                const idx = gw2Waypoints.findIndex(w => w.id === id);
                if (idx !== -1) {
                    gw2Waypoints.splice(idx, 1);
                    container.querySelectorAll('.marker.gw2[data-type="waypoint"]').forEach(el => el.remove());
                    gw2Waypoints.forEach((w, i) => { w.id = i; createGW2MarkerElement('waypoint', w.x, w.y, i, true); });
                }
            } else {
                const idx = markers.gw2[type].findIndex(m => m.id === id);
                if (idx !== -1) {
                    markers.gw2[type].splice(idx, 1);
                    container.querySelectorAll(`.marker.gw2[data-type="${type}"]`).forEach(el => el.remove());
                    markers.gw2[type].forEach((m, i) => { m.id = i; createGW2MarkerElement(type, m.x, m.y, i); });
                }
            }
            
            optimalRoute = []; previewRoute = []; allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            updateLegend();
            drawCanvas();
        }
        
        function clearAll() {
            const container = document.getElementById('canvasContainer');
            container.querySelectorAll('.marker').forEach(m => m.remove());
            if (currentMode === 'tsp') {
                markers = { start: null, ends: [], Markers: [], Waypoints: [], gw2: markers.gw2, gw2Start: markers.gw2Start, gw2Ends: markers.gw2Ends };
            } else {
                markers.gw2 = {};
                GW2_MARKERS.forEach(m => {
                    if (!m.isSpecial) markers.gw2[m.type] = [];
                });
                markers.gw2Start = null;
                markers.gw2Ends = [];
                gw2Waypoints = [];
            }
            markerElements = []; optimalRoute = []; previewRoute = []; allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            updateEndpointModeVisibility();
            updateLegend();
            if (img) drawCanvas();
        }
        
        let distanceCache = new Map();
        function clearDistanceCache() { distanceCache.clear(); }
        
        function calculatePath() {
            if (currentMode === 'tsp') {
                if (!markers.start) { alert('Please set a start point'); return; }
                if (endpointMode === 'and' && markers.ends.length > 0 && markers.Waypoints.length === 0) {
                    alert('AND mode requires at least one Waypoint to handle mandatory teleportation from endpoints!');
                    return;
                }
                if (markers.Markers.length > 25 && !confirm(`You have ${markers.Markers.length} Markers. Continue?`)) return;
            } else {
                // GW2 mode validation
                if (!markers.gw2Start) {
                    alert('Please set a start point');
                    return;
                }
                
                let totalPoints = 0;
                Object.keys(markers.gw2).forEach(type => {
                    totalPoints += markers.gw2[type].length;
                });
                
                if (totalPoints === 0) {
                    alert('Please place at least one marker on the map');
                    return;
                }
                
                // Check if requirements are met
                let unmetRequirements = [];
                Object.keys(gw2Requirements).forEach(type => {
                    const required = gw2Requirements[type];
                    if (required === 0) return; // Skip if 0 (optional)
                    const available = markers.gw2[type].length;
                    if (required > available) {
                        const markerDef = GW2_MARKERS.find(m => m.type === type);
                        unmetRequirements.push(`${markerDef.name}: need ${required}, have ${available}`);
                    }
                });
                
                if (unmetRequirements.length > 0) {
                    alert('Requirements not met:\n' + unmetRequirements.join('\n'));
                    return;
                }
            }
            
            clearDistanceCache();
            const resultsPanel = document.getElementById('resultsPanel');
            const resultsContent = document.getElementById('resultsContent');
            resultsPanel.classList.add('active');
            resultsContent.innerHTML = '<div class="computing"><div class="computing-spinner">‚öôÔ∏è</div><p>Computing routes...</p></div>';
            
            setTimeout(() => {
                try {
                    const results = runAllAlgorithms();
                    displayResults(results);
                    if (!resultsContent.classList.contains('expanded')) toggleResults();
                } catch (error) {
                    console.error('Error computing routes:', error);
                    resultsContent.innerHTML = '<div class="computing"><p style="color: #f56565;">Error computing routes.</p></div>';
                }
            }, 100);
        }
        
        function runAllAlgorithms() {
            if (currentMode === 'gw2') {
                return runGW2Algorithms();
            }
            
            const start = markers.start;
            const Markers = markers.Markers;
            let scenarios = [];
            
            if (endpointMode === 'or' && markers.ends.length > 0) {
                markers.ends.forEach(end => {
                    scenarios.push({ destination: end, pointsToVisit: [...Markers] });
                });
            } else if (endpointMode === 'and') {
                scenarios.push({ destination: null, pointsToVisit: [...Markers, ...markers.ends] });
            } else {
                scenarios.push({ destination: markers.ends.length > 0 ? markers.ends[0] : null, pointsToVisit: [...Markers] });
            }

            const runAlgorithm = (algoName, algoFunc) => {
                let bestForAlgo = null;
                let minAlgoDist = Infinity;
                scenarios.forEach(scenario => {
                    const rawPath = algoFunc(start, scenario.destination, scenario.pointsToVisit);
                    const processedPath = insertWaypointsInPath(rawPath);
                    const dist = calculatePathDistance(processedPath);
                    if (dist < minAlgoDist) {
                        minAlgoDist = dist;
                        bestForAlgo = { name: algoName, path: processedPath, distance: dist };
                    }
                });
                return bestForAlgo;
            };

            const results = [];
            const pointCount = Math.max(...scenarios.map(s => s.pointsToVisit.length));

            if (pointCount <= 7) results.push(runAlgorithm('Brute Force (Optimal)', bruteForceAllPoints));
            results.push(runAlgorithm('Nearest Neighbor', nearestNeighborAllPoints));
            if (pointCount <= 20) {
                results.push(runAlgorithm('Nearest Neighbor + 2-Opt', (s, e, p) => twoOptImprove(nearestNeighborAllPoints(s, e, p))));
            }
            results.push(runAlgorithm('Greedy Insertion', greedyInsertion));
            const attempts = pointCount <= 10 ? 15 : pointCount <= 15 ? 10 : 5;
            results.push(runAlgorithm(`Random Restart (${attempts}x)`, (s, e, p) => randomRestart(s, e, p, attempts)));
            
            return results;
        }
        
        function runGW2Algorithms() {
            if (!markers.gw2Start) {
                alert('Please set a start point');
                return [];
            }
            
            // Collect all required points
            let requiredPoints = [];
            let optionalPoints = [];
            
            Object.keys(markers.gw2).forEach(type => {
                const required = gw2Requirements[type];
                const available = markers.gw2[type];
                
                if (required > 0) {
                    // Must visit exactly 'required' of this type
                    // For now, take first N (optimization TODO: choose best subset)
                    requiredPoints.push(...available.slice(0, required));
                    // Rest are optional
                    if (available.length > required) {
                        optionalPoints.push(...available.slice(required));
                    }
                } else {
                    // All are optional
                    optionalPoints.push(...available);
                }
            });
            
            // For now, include all optional points (future: optimize which to visit)
            const pointsToVisit = [...requiredPoints, ...optionalPoints];
            
            if (pointsToVisit.length === 0) {
                alert('No points to visit (all optional with 0 required)');
                return [];
            }
            
            const start = markers.gw2Start;
            const ends = markers.gw2Ends;
            
            // Temporarily set TSP markers for algorithm to use
            const oldStart = markers.start;
            const oldEnds = markers.ends;
            const oldMarkers = markers.Markers;
            const oldWaypoints = markers.Waypoints;
            
            markers.start = start;
            markers.ends = ends;
            markers.Markers = pointsToVisit;
            markers.Waypoints = gw2Waypoints;
            
            let scenarios = [];
            if (ends.length > 0) {
                ends.forEach(end => {
                    scenarios.push({ destination: end, pointsToVisit: [...pointsToVisit] });
                });
            } else {
                scenarios.push({ destination: null, pointsToVisit: [...pointsToVisit] });
            }

            const runAlgorithm = (algoName, algoFunc) => {
                let bestForAlgo = null;
                let minAlgoDist = Infinity;
                scenarios.forEach(scenario => {
                    const rawPath = algoFunc(start, scenario.destination, scenario.pointsToVisit);
                    const processedPath = insertWaypointsInPathGeneric(rawPath);
                    const dist = calculatePathDistanceGeneric(processedPath);
                    if (dist < minAlgoDist) {
                        minAlgoDist = dist;
                        bestForAlgo = { name: algoName, path: processedPath, distance: dist };
                    }
                });
                return bestForAlgo;
            };

            const results = [];
            const pointCount = Math.max(...scenarios.map(s => s.pointsToVisit.length));

            if (pointCount <= 7) results.push(runAlgorithm('Brute Force (Optimal)', bruteForceAllPoints));
            results.push(runAlgorithm('Nearest Neighbor', nearestNeighborAllPoints));
            if (pointCount <= 20) {
                results.push(runAlgorithm('Nearest Neighbor + 2-Opt', (s, e, p) => twoOptImprove(nearestNeighborAllPoints(s, e, p))));
            }
            results.push(runAlgorithm('Greedy Insertion', greedyInsertion));
            const attempts = pointCount <= 10 ? 15 : pointCount <= 15 ? 10 : 5;
            results.push(runAlgorithm(`Random Restart (${attempts}x)`, (s, e, p) => randomRestart(s, e, p, attempts)));
            
            // Restore TSP markers
            markers.start = oldStart;
            markers.ends = oldEnds;
            markers.Markers = oldMarkers;
            markers.Waypoints = oldWaypoints;
            
            return results;
        }
        
        function bruteForceAllPoints(start, end, points) {
            if (points.length === 0) return end ? [start, end] : [start];
            let bestPath = null, bestDist = Infinity, permCount = 0;
            const maxPerms = 50000;
            
            function permute(remaining, currentPath) {
                if (++permCount > maxPerms) return;
                if (remaining.length === 0) {
                    const fullPath = end ? [...currentPath, end] : currentPath;
                    const dist = currentMode === 'gw2' ? calculatePathDistanceGeneric(fullPath) : calculatePathDistance(fullPath);
                    if (dist < bestDist) { bestDist = dist; bestPath = fullPath; }
                    return;
                }
                for (let i = 0; i < remaining.length; i++) {
                    const next = remaining[i];
                    permute(remaining.filter((_, idx) => idx !== i), [...currentPath, next]);
                }
            }
            permute(points, [start]);
            return bestPath || [start, ...(end ? [end] : [])];
        }
        
        function nearestNeighborAllPoints(start, end, points) {
            if (points.length === 0) return end ? [start, end] : [start];
            const path = [start];
            let current = start;
            const remaining = new Set(points);
            const discoveredWaypoints = new Set();
            updateDiscoveredWaypoints(current, discoveredWaypoints);
            
            while (remaining.size > 0) {
                let nearest = null, minDist = Infinity;
                let bestWaypointDetour = null;
                
                for (const point of remaining) {
                    const directDist = distanceWithDiscovery(current, point, discoveredWaypoints);
                    
                    if (WaypointDiscoveryMode) {
                        for (const waypoint of markers.Waypoints) {
                            if (!isWaypointDiscovered(waypoint, discoveredWaypoints)) {
                                const detourDist = euclideanDistance(current, waypoint) + euclideanDistance(waypoint, point);
                                const futureSavings = estimateWaypointValue(waypoint, remaining, discoveredWaypoints);
                                const effectiveCost = detourDist - (futureSavings / remaining.size);
                                
                                if (effectiveCost < directDist && effectiveCost < minDist) {
                                    minDist = effectiveCost;
                                    nearest = point;
                                    bestWaypointDetour = waypoint;
                                }
                            }
                        }
                    }
                    
                    if (directDist < minDist) {
                        minDist = directDist;
                        nearest = point;
                        bestWaypointDetour = null;
                    }
                }
                
                if (nearest) {
                    if (bestWaypointDetour) {
                        const waypointCopy = { ...bestWaypointDetour, explicitVisit: true };
                        path.push(waypointCopy);
                        current = waypointCopy;
                        updateDiscoveredWaypoints(current, discoveredWaypoints);
                    }
                    
                    updateDiscoveriesAlongSegment(current, nearest, discoveredWaypoints);
                    path.push(nearest);
                    current = nearest;
                    updateDiscoveredWaypoints(current, discoveredWaypoints);
                    remaining.delete(nearest);
                }
            }
            if (end) path.push(end);
            return path;
        }
        
        function twoOptImprove(path) {
            if (path.length < 4) return path;
            let improved = true, bestPath = [...path], iterations = 0;
            const maxIterations = Math.min(50, path.length * 2);
            
            while (improved && iterations < maxIterations) {
                improved = false; iterations++;
                for (let i = 1; i < bestPath.length - 2; i++) {
                    for (let j = i + 1; j < bestPath.length - 1; j++) {
                        const currentCost = calculatePathDistance(bestPath);
                        const newPath = [...bestPath];
                        newPath.splice(i, j - i + 1, ...newPath.slice(i, j + 1).reverse());
                        const newCost = calculatePathDistance(newPath);
                        
                        if (newCost < currentCost) {
                            bestPath = newPath; improved = true;
                        }
                    }
                }
            }
            return bestPath;
        }
        
        function greedyInsertion(start, end, points) {
            if (points.length === 0) return end ? [start, end] : [start];
            const path = [start, points[0]];
            if (end) path.push(end);
            const remaining = new Set(points.slice(1));
            const discoveredWaypoints = new Set();
            updateDiscoveredWaypoints(start, discoveredWaypoints);
            updateDiscoveriesAlongSegment(start, points[0], discoveredWaypoints);
            updateDiscoveredWaypoints(points[0], discoveredWaypoints);
            let totalChecks = 0;
            const MAX_CHECKS = 10000;
            
            while (remaining.size > 0) {
                let bestPoint = null, bestPosition = -1, bestIncrease = Infinity;
                let bestWaypointDetour = null, bestWaypointPosition = -1;
                
                for (const point of remaining) {
                    const maxPos = end ? path.length - 1 : path.length;
                    for (let i = 1; i < maxPos; i++) {
                        totalChecks++;
                        if (totalChecks > MAX_CHECKS) {
                            const insertPos = end ? path.length - 1 : path.length;
                            Array.from(remaining).forEach(p => path.splice(insertPos, 0, p));
                            return path;
                        }
                        const before = path[i - 1], after = path[i];
                        const currentDist = distanceWithDiscovery(before, after, discoveredWaypoints);
                        const newDist = distanceWithDiscovery(before, point, discoveredWaypoints) + 
                                      distanceWithDiscovery(point, after, discoveredWaypoints);
                        const increase = newDist - currentDist;
                        
                        if (WaypointDiscoveryMode) {
                            for (const waypoint of markers.Waypoints) {
                                if (!isWaypointDiscovered(waypoint, discoveredWaypoints)) {
                                    const detourDist = euclideanDistance(before, waypoint) + 
                                                      euclideanDistance(waypoint, point) + 
                                                      distanceWithDiscovery(point, after, discoveredWaypoints);
                                    const futureSavings = estimateWaypointValue(waypoint, remaining, discoveredWaypoints);
                                    const effectiveIncrease = (detourDist - currentDist) - (futureSavings / remaining.size);
                                    
                                    if (effectiveIncrease < bestIncrease) {
                                        bestIncrease = effectiveIncrease;
                                        bestPoint = point;
                                        bestPosition = i;
                                        bestWaypointDetour = waypoint;
                                        bestWaypointPosition = i;
                                    }
                                }
                            }
                        }
                        
                        if (increase < bestIncrease) {
                            bestIncrease = increase;
                            bestPoint = point;
                            bestPosition = i;
                            bestWaypointDetour = null;
                        }
                    }
                }
                
                if (bestPoint) {
                    if (bestWaypointDetour) {
                        const waypointCopy = { ...bestWaypointDetour, explicitVisit: true };
                        path.splice(bestWaypointPosition, 0, waypointCopy);
                        updateDiscoveredWaypoints(waypointCopy, discoveredWaypoints);
                        if (bestPosition >= bestWaypointPosition) bestPosition++;
                    }
                    
                    const before = path[bestPosition - 1];
                    updateDiscoveriesAlongSegment(before, bestPoint, discoveredWaypoints);
                    path.splice(bestPosition, 0, bestPoint);
                    updateDiscoveredWaypoints(bestPoint, discoveredWaypoints);
                    remaining.delete(bestPoint);
                } else {
                    const insertPos = end ? path.length - 1 : path.length;
                    Array.from(remaining).forEach(p => path.splice(insertPos, 0, p));
                    break;
                }
            }
            return path;
        }
        
        function randomRestart(start, end, points, attempts) {
            if (points.length === 0) return end ? [start, end] : [start];
            let bestPath = null, bestDist = Infinity;
            
            for (let attempt = 0; attempt < attempts; attempt++) {
                let attemptBestPath = null, attemptBestDist = Infinity;
                const shuffled = [...points].sort(() => Math.random() - 0.5);
                
                for (let run = 0; run < 3; run++) {
                    const path = end ? [start, ...shuffled, end] : [start, ...shuffled];
                    const improved = twoOptImprove(path);
                    const dist = calculatePathDistance(improved);
                    if (dist < attemptBestDist) { attemptBestDist = dist; attemptBestPath = improved; }
                }
                if (attemptBestDist < bestDist) { bestDist = attemptBestDist; bestPath = attemptBestPath; }
            }
            return bestPath || [start, ...(end ? [end] : [])];
        }
        
        let suppressDiscoveryLogs = false;
        
        function lineSegmentIntersectsCircle(p1, p2, center, radius) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const fx = p1.x - center.x;
            const fy = p1.y - center.y;
            
            const a = dx * dx + dy * dy;
            if (a < 0.001) return euclideanDistance(p1, center) <= radius;
            
            const b = 2 * (fx * dx + fy * dy);
            const c = (fx * fx + fy * fy) - radius * radius;
            const discriminant = b * b - 4 * a * c;
            
            if (discriminant < 0) return false;
            
            const sqrtDisc = Math.sqrt(discriminant);
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);
            
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }
        
        function updateDiscoveredWaypoints(point, discoveredWaypoints) {
            if (!WaypointDiscoveryMode) { markers.Waypoints.forEach(w => discoveredWaypoints.add(w)); return; }
            for (const Waypoint of markers.Waypoints) {
                if (euclideanDistance(point, Waypoint) <= Waypoint.radius) discoveredWaypoints.add(Waypoint);
            }
        }
        
        function updateDiscoveredWaypointsGeneric(point, discoveredWaypoints) {
            const waypointsToCheck = currentMode === 'tsp' ? markers.Waypoints : gw2Waypoints;
            if (!WaypointDiscoveryMode) { waypointsToCheck.forEach(w => discoveredWaypoints.add(w)); return; }
            for (const Waypoint of waypointsToCheck) {
                if (euclideanDistance(point, Waypoint) <= Waypoint.radius) discoveredWaypoints.add(Waypoint);
            }
        }
        
        function updateDiscoveriesAlongSegment(p1, p2, discoveredWaypoints) {
            if (!WaypointDiscoveryMode) return;
            for (const Waypoint of markers.Waypoints) {
                if (!discoveredWaypoints.has(Waypoint) && lineSegmentIntersectsCircle(p1, p2, Waypoint, Waypoint.radius)) {
                    discoveredWaypoints.add(Waypoint);
                }
            }
        }
        
        function updateDiscoveriesAlongSegmentGeneric(p1, p2, discoveredWaypoints) {
            if (!WaypointDiscoveryMode) return;
            const waypointsToCheck = currentMode === 'tsp' ? markers.Waypoints : gw2Waypoints;
            for (const Waypoint of waypointsToCheck) {
                if (!discoveredWaypoints.has(Waypoint) && lineSegmentIntersectsCircle(p1, p2, Waypoint, Waypoint.radius)) {
                    discoveredWaypoints.add(Waypoint);
                }
            }
        }
        
        function isWaypointDiscovered(Waypoint, discoveredWaypoints) {
            return !WaypointDiscoveryMode || discoveredWaypoints.has(Waypoint);
        }
        
        function estimateWaypointValue(waypoint, remainingPoints, discoveredWaypoints) {
            if (isWaypointDiscovered(waypoint, discoveredWaypoints)) return 0;
            
            let potentialSavings = 0;
            const pointsArray = Array.from(remainingPoints);
            
            for (let i = 0; i < pointsArray.length; i++) {
                for (let j = i + 1; j < pointsArray.length; j++) {
                    const directDist = euclideanDistance(pointsArray[i], pointsArray[j]);
                    const viaWaypointDist = TELEPORT_COST + euclideanDistance(waypoint, pointsArray[j]);
                    const saving = Math.max(0, directDist - viaWaypointDist);
                    potentialSavings += saving * 0.2;
                }
            }
            
            return potentialSavings;
        }
        
        function distanceWithDiscovery(p1, p2, discoveredWaypoints) {
            if (p1.type === 'Waypoint') return euclideanDistance(p1, p2);

            let bestDist = euclideanDistance(p1, p2);
            if (endpointMode === 'and' && p1.type === 'end' && markers.Waypoints.length > 0) {
                bestDist = Infinity;
            }
            
            if (p2.type === 'Waypoint' && p2.explicitVisit) {
                return euclideanDistance(p1, p2);
            }
            
            if (p2.type === 'Waypoint') {
                return isWaypointDiscovered(p2, discoveredWaypoints) ? TELEPORT_COST : 999999;
            }
            
            if (markers.Waypoints.length === 0) return bestDist;

            for (const Waypoint of markers.Waypoints) {
                if (!isWaypointDiscovered(Waypoint, discoveredWaypoints)) continue;
                const totalViaWaypoint = TELEPORT_COST + euclideanDistance(Waypoint, p2);
                if (totalViaWaypoint < bestDist) {
                    bestDist = totalViaWaypoint;
                }
            }
            return bestDist;
        }
        
        function distanceWithDiscoveryGeneric(p1, p2, discoveredWaypoints) {
            const isP1Waypoint = (p1.type === 'Waypoint' || p1.type === 'waypoint');
            const isP2Waypoint = (p2.type === 'Waypoint' || p2.type === 'waypoint');
            
            if (isP1Waypoint) return euclideanDistance(p1, p2);

            let bestDist = euclideanDistance(p1, p2);
            
            if (isP2Waypoint && p2.explicitVisit) {
                return euclideanDistance(p1, p2);
            }
            
            if (isP2Waypoint) {
                return isWaypointDiscoveredGeneric(p2, discoveredWaypoints) ? TELEPORT_COST : 999999;
            }
            
            const waypointsToUse = currentMode === 'tsp' ? markers.Waypoints : gw2Waypoints;
            if (waypointsToUse.length === 0) return bestDist;

            for (const Waypoint of waypointsToUse) {
                if (!isWaypointDiscoveredGeneric(Waypoint, discoveredWaypoints)) continue;
                const totalViaWaypoint = TELEPORT_COST + euclideanDistance(Waypoint, p2);
                if (totalViaWaypoint < bestDist) {
                    bestDist = totalViaWaypoint;
                }
            }
            return bestDist;
        }
        
        function findBestWaypoint(p1, p2, discoveredWaypoints) {
            if (p1.type === 'Waypoint' || p2.type === 'Waypoint') return null;
            
            let directDist = euclideanDistance(p1, p2);
            if (endpointMode === 'and' && p1.type === 'end' && markers.Waypoints.length > 0) {
                directDist = Infinity;
            }
            
            let bestWaypoint = null;
            let bestDist = directDist;
            
            for (const Waypoint of markers.Waypoints) {
                if (!isWaypointDiscovered(Waypoint, discoveredWaypoints)) continue;
                const WaypointPath = TELEPORT_COST + euclideanDistance(Waypoint, p2);
                if (WaypointPath < bestDist) {
                    bestDist = WaypointPath;
                    bestWaypoint = Waypoint;
                }
            }
            return bestWaypoint;
        }
        
        function findBestWaypointGeneric(p1, p2, discoveredWaypoints) {
            const isP1Waypoint = (p1.type === 'Waypoint' || p1.type === 'waypoint');
            const isP2Waypoint = (p2.type === 'Waypoint' || p2.type === 'waypoint');
            if (isP1Waypoint || isP2Waypoint) return null;
            
            let directDist = euclideanDistance(p1, p2);
            
            let bestWaypoint = null;
            let bestDist = directDist;
            
            const waypointsToUse = currentMode === 'tsp' ? markers.Waypoints : gw2Waypoints;
            for (const Waypoint of waypointsToUse) {
                if (!isWaypointDiscoveredGeneric(Waypoint, discoveredWaypoints)) continue;
                const WaypointPath = TELEPORT_COST + euclideanDistance(Waypoint, p2);
                if (WaypointPath < bestDist) {
                    bestDist = WaypointPath;
                    bestWaypoint = Waypoint;
                }
            }
            return bestWaypoint;
        }
        
        function insertWaypointsInPath(path) {
            const discoveredWaypoints = new Set();
            if (!WaypointDiscoveryMode) markers.Waypoints.forEach(w => discoveredWaypoints.add(w));
            
            const newPath = [path[0]];
            updateDiscoveredWaypoints(path[0], discoveredWaypoints);
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const current = path[i];
                
                if (current.type === 'Waypoint' && current.explicitVisit) {
                    newPath.push(current);
                    updateDiscoveredWaypoints(current, discoveredWaypoints);
                    continue;
                }
                
                const Waypoint = findBestWaypoint(prev, current, discoveredWaypoints);
                
                if (Waypoint) {
                    newPath.push(Waypoint);
                }
                
                updateDiscoveriesAlongSegment(prev, current, discoveredWaypoints);
                
                newPath.push(current);
                updateDiscoveredWaypoints(current, discoveredWaypoints);
            }
            return newPath;
        }
        
        function insertWaypointsInPathGeneric(path) {
            const waypointsToUse = currentMode === 'tsp' ? markers.Waypoints : gw2Waypoints;
            const discoveredWaypoints = new Set();
            if (!WaypointDiscoveryMode) waypointsToUse.forEach(w => discoveredWaypoints.add(w));
            
            const newPath = [path[0]];
            updateDiscoveredWaypointsGeneric(path[0], discoveredWaypoints);
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const current = path[i];
                
                const isWaypointType = (current.type === 'Waypoint' || current.type === 'waypoint');
                if (isWaypointType && current.explicitVisit) {
                    newPath.push(current);
                    updateDiscoveredWaypointsGeneric(current, discoveredWaypoints);
                    continue;
                }
                
                const Waypoint = findBestWaypointGeneric(prev, current, discoveredWaypoints);
                
                if (Waypoint) {
                    newPath.push(Waypoint);
                }
                
                updateDiscoveriesAlongSegmentGeneric(prev, current, discoveredWaypoints);
                
                newPath.push(current);
                updateDiscoveredWaypointsGeneric(current, discoveredWaypoints);
            }
            return newPath;
        }
        
        function euclideanDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        
        function displayResults(results) {
            const resultsContent = document.getElementById('resultsContent');
            allResults = results;
            const bestResult = results.reduce((best, current) => current.distance < best.distance ? current : best);
            optimalRoute = bestResult.path;
            previewRoute = [];
            drawCanvas();
            
            let html = '';
            results.forEach((result, index) => {
                const isBest = result === bestResult;
                const routeStr = formatRoute(result.path);
                html += `
                    <div class="method-result ${isBest ? 'best' : ''}" 
                         data-result-index="${index}"
                         onmouseenter="previewResult(${index})"
                         onmouseleave="clearPreview()">
                        <div class="method-name">
                            <span>${result.name}</span>
                            ${isBest ? '<span class="badge">BEST</span>' : ''}
                        </div>
                        <div class="method-distance">${result.distance.toFixed(2)} pixels</div>
                        <div class="method-route">${routeStr}</div>
                    </div>`;
            });
            resultsContent.innerHTML = html;
        }
        
        function previewResult(index) { if (allResults[index]) { previewRoute = allResults[index].path; drawCanvas(); } }
        function clearPreview() { previewRoute = []; drawCanvas(); }
        
        function formatRoute(path) {
            return path.map(point => {
                if (point.type === 'start') return 'Start';
                if (point.type === 'end') return `E${point.id + 1}`;
                if (point.type === 'Waypoint') {
                    return point.explicitVisit ? `üö∂W${point.id + 1}` : `‚ö°W${point.id + 1}`;
                }
                if (point.type === 'waypoint') {
                    return point.explicitVisit ? `üö∂WP${point.id + 1}` : `‚ö°WP${point.id + 1}`;
                }
                if (point.type === 'Marker') return `P${point.id + 1}`;
                
                // GW2 markers
                const markerDef = GW2_MARKERS.find(m => m.type === point.type);
                if (markerDef) {
                    const prefix = markerDef.name.split(' ').map(w => w[0]).join('');
                    return `${prefix}${point.id + 1}`;
                }
                return `?${point.id + 1}`;
            }).join(' ‚Üí ');
        }
        
        function calculatePathDistance(path) {
            if (!path || path.length < 2) return 0;
            suppressDiscoveryLogs = true;
            let total = 0;
            const discoveredWaypoints = new Set();
            if (!WaypointDiscoveryMode) markers.Waypoints.forEach(w => discoveredWaypoints.add(w));
            
            for (let i = 0; i < path.length - 1; i++) {
                const current = path[i];
                const next = path[i + 1];
                
                updateDiscoveredWaypoints(current, discoveredWaypoints);
                total += distanceWithDiscovery(current, next, discoveredWaypoints);
                updateDiscoveriesAlongSegment(current, next, discoveredWaypoints);
            }
            suppressDiscoveryLogs = false;
            return total;
        }
        
        // Initialize
        updateLegend();
    </script>
</body>
</html>
