<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP Path Finder</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        h1 { color: #333; margin-bottom: 10px; font-size: 28px; }
        .subtitle { color: #666; margin-bottom: 25px; font-size: 14px; }
        .controls { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
        .input-group { display: flex; gap: 10px; align-items: center; }
        input[type="text"], input[type="number"] { padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; }
        input[type="text"] { width: 300px; }
        input[type="number"] { width: 80px; }
        button {
            padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px;
            cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s;
        }
        button:hover { background: #5568d3; transform: translateY(-2px); }
        button:active { transform: translateY(0); }
        button.secondary { background: #48bb78; }
        button.secondary:hover { background: #38a169; }
        button.danger { background: #f56565; }
        button.danger:hover { background: #e53e3e; }
        input[type="file"] { display: none; }
        
        .marker-type-selector {
            display: flex; gap: 10px; padding: 15px; background: #f7fafc;
            border-radius: 8px; margin-bottom: 15px; flex-wrap: wrap;
        }
        .marker-type-btn {
            padding: 12px 20px; background: white; border: 3px solid #e2e8f0; border-radius: 8px;
            cursor: pointer; font-weight: 600; transition: all 0.2s; display: flex; align-items: center; gap: 8px;
        }
        .marker-type-btn:hover { border-color: #cbd5e0; transform: translateY(-2px); }
        .marker-type-btn.active { border-width: 4px; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2); }
        .marker-type-btn.start.active { border-color: #48bb78; background: #f0fff4; }
        .marker-type-btn.end.active { border-color: #f56565; background: #fff5f5; }
        .marker-type-btn.Marker.active { border-color: #4299e1; background: #ebf8ff; }
        .marker-type-btn.Waypoint.active { border-color: #9f7aea; background: #faf5ff; }
        
        .marker-icon { width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .marker-icon.Waypoint { border-style: dashed; }
        
        .options-panel {
            display: flex; gap: 15px; padding: 12px 15px; background: #faf5ff;
            border-radius: 8px; margin-bottom: 15px; flex-wrap: wrap; align-items: center; border: 2px solid #d6bcfa;
        }
        .option-group { display: flex; align-items: center; gap: 8px; }
        .option-group label { font-weight: 600; color: #553c9a; font-size: 14px; }
        input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        
        .endpoint-mode-selector {
            display: flex; gap: 10px; padding: 12px 15px; background: #fff5f5;
            border-radius: 8px; margin-bottom: 15px; align-items: center; border: 2px solid #feb2b2;
        }
        .endpoint-mode-selector label { font-weight: 600; color: #742a2a; margin-right: 10px; }
        .mode-option {
            padding: 8px 16px; background: white; border: 2px solid #e2e8f0; border-radius: 6px;
            cursor: pointer; font-weight: 600; transition: all 0.2s; font-size: 13px;
        }
        .mode-option:hover { border-color: #cbd5e0; }
        .mode-option.active { border-color: #f56565; background: #fff5f5; color: #c53030; }
        .mode-description { font-size: 12px; color: #744210; margin-left: auto; font-style: italic; }
        
        .main-content { display: grid; grid-template-columns: 1fr 450px; gap: 20px; margin-top: 20px; }
        @media (max-width: 1200px) { .main-content { grid-template-columns: 1fr; } }
        
        .canvas-container {
            position: relative; border: 3px solid #667eea; border-radius: 8px; overflow: hidden;
            background: #f7f7f7; min-height: 400px; display: flex; align-items: center; justify-content: center;
        }
        canvas { display: block; cursor: crosshair; }
        
        .marker {
            position: absolute; width: 28px; height: 28px; border-radius: 50%; border: 3px solid white;
            cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transform: translate(-50%, -50%);
            display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;
            color: white; transition: all 0.2s; z-index: 10;
        }
        .marker:hover { transform: translate(-50%, -50%) scale(1.3); box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
        .marker.start { background: #48bb78; }
        .marker.end { background: #f56565; }
        .marker.Marker { background: #4299e1; }
        .marker.Waypoint { background: #9f7aea; border-style: dashed; cursor: ns-resize; }
        
        .legend {
            margin-top: 20px; padding: 15px; background: #f7fafc; border-radius: 6px;
            display: flex; gap: 20px; flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 13px; }
        .legend-marker { width: 18px; height: 18px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .legend-marker.Waypoint { border-style: dashed; }
        
        .results-panel { display: none; }
        .results-panel.active { display: block; }
        .results-header {
            background: #667eea; color: white; padding: 15px 20px; border-radius: 8px 8px 0 0;
            font-weight: 600; font-size: 16px; cursor: pointer; display: flex; justify-content: space-between;
            align-items: center; user-select: none;
        }
        .results-header:hover { background: #5568d3; }
        .toggle-icon { font-size: 20px; transition: transform 0.3s; }
        .toggle-icon.expanded { transform: rotate(180deg); }
        
        .results-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .results-content.expanded { max-height: 2000px; }
        
        .method-result {
            border: 2px solid #e2e8f0; border-top: none; padding: 15px; background: white;
            transition: all 0.2s; cursor: pointer; position: relative;
        }
        .method-result:hover {
            background: #ebf8ff; border-color: #4299e1; transform: translateX(5px);
            box-shadow: -3px 0 0 #4299e1;
        }
        .method-result:hover::before {
            content: 'üëÅÔ∏è Previewing route'; position: absolute; top: 10px; right: 15px;
            font-size: 11px; color: #4299e1; font-weight: 600;
        }
        .method-result:last-child { border-radius: 0 0 8px 8px; }
        .method-result.best { background: #f0fff4; border-color: #48bb78; border-width: 3px; }
        
        .method-name {
            font-weight: 700; color: #2d3748; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .method-name .badge {
            background: #48bb78; color: white; padding: 3px 8px; border-radius: 4px;
            font-size: 11px; font-weight: 600;
        }
        .method-distance { color: #667eea; font-weight: 600; font-size: 18px; margin-bottom: 8px; }
        .method-route { color: #4a5568; font-size: 13px; line-height: 1.6; word-break: break-word; }
        
        .placeholder { text-align: center; color: #999; padding: 40px; }
        .placeholder-icon { font-size: 64px; margin-bottom: 15px; }
        .computing { text-align: center; padding: 30px; color: #667eea; }
        .computing-spinner { font-size: 32px; animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Traveling Salesman Path Finder</h1>
        <p class="subtitle">Upload an image and place markers. <br><strong>Discovery Mode:</strong> Algorithms detour to waypoints (üö∂) only if it results in shorter total path. Line-of-sight also discovers. Drag waypoints to resize.</p>
        
        <div class="controls">
            <div class="input-group">
                <input type="text" id="imageUrl" placeholder="Enter image URL...">
                <button onclick="loadImageFromUrl()">Load URL</button>
            </div>
            <label for="imageFile">
                <button onclick="document.getElementById('imageFile').click()">Upload Image</button>
            </label>
            <input type="file" id="imageFile" accept="image/*" onchange="loadImageFromFile(event)">
            <button class="secondary" onclick="calculatePath()">Find Shortest Path</button>
            <button class="danger" onclick="clearAll()">Clear All</button>
        </div>
        
        <div class="marker-type-selector">
            <div class="marker-type-btn start active" onclick="selectMarkerType('start')">
                <div class="marker-icon" style="background: #48bb78;"></div>
                <span>Start Point</span>
            </div>
            <div class="marker-type-btn end" onclick="selectMarkerType('end')">
                <div class="marker-icon" style="background: #f56565;"></div>
                <span>End Points</span>
            </div>
            <div class="marker-type-btn Marker" onclick="selectMarkerType('Marker')">
                <div class="marker-icon" style="background: #4299e1;"></div>
                <span>Markers</span>
            </div>
            <div class="marker-type-btn Waypoint" onclick="selectMarkerType('Waypoint')">
                <div class="marker-icon Waypoint" style="background: #9f7aea;"></div>
                <span>Waypoint</span>
            </div>
        </div>
        
        <div class="options-panel">
            <div class="option-group">
                <input type="checkbox" id="WaypointDiscovery" onchange="toggleWaypointDiscovery()">
                <label for="WaypointDiscovery">Waypoint Discovery Mode</label>
            </div>
        </div>
        
        <div class="endpoint-mode-selector" id="endpointModeSelector" style="display: none;">
            <label>Multiple Endpoints Mode:</label>
            <div class="mode-option active" onclick="selectEndpointMode('or')">OR (any)</div>
            <div class="mode-option" onclick="selectEndpointMode('and')">AND (all)</div>
            <div class="mode-description" id="modeDescription">Choose best endpoint to finish</div>
        </div>
        
        <div class="main-content">
            <div>
                <div class="canvas-container" id="canvasContainer">
                    <div class="placeholder">
                        <div class="placeholder-icon">üìç</div>
                        <p>Load an image to get started</p>
                    </div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #48bb78;"></div>
                        <span>Start (required)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #f56565;"></div>
                        <span>End</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #4299e1;"></div>
                        <span>Markers</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker Waypoint" style="background: #9f7aea;"></div>
                        <span>Waypoints (Drag to resize ‚Ä¢ ‚úì = discovered)</span>
                    </div>
                    <div class="legend-item" style="margin-left: auto; font-style: italic; color: #666;">
                        <span>üí° Hover over results to preview routes</span>
                    </div>
                </div>
            </div>
            
            <div class="results-panel" id="resultsPanel">
                <div class="results-header" onclick="toggleResults()">
                    <span>üìä Algorithm Comparison</span>
                    <span class="toggle-icon" id="toggleIcon">‚ñº</span>
                </div>
                <div class="results-content" id="resultsContent"></div>
            </div>
        </div>
    </div>

    <script>
        let canvas, ctx;
        let img = null;
        let markers = {
            start: null,
            ends: [],
            Markers: [],
            Waypoints: []
        };
        let optimalRoute = [];
        let previewRoute = [];
        let allResults = [];
        let markerElements = [];
        let selectedMarkerType = 'start';
        let endpointMode = 'or';
        let WaypointDiscoveryMode = false;
        const TELEPORT_COST = 0; 
        
        let resizingWaypoint = null;
        let isDraggingRadius = false;
        
        function selectMarkerType(type) {
            selectedMarkerType = type;
            document.querySelectorAll('.marker-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.marker-type-btn.${type}`).classList.add('active');
        }
        
        function toggleWaypointDiscovery() {
            WaypointDiscoveryMode = document.getElementById('WaypointDiscovery').checked;
            optimalRoute = [];
            previewRoute = [];
            allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            drawCanvas();
        }
        
        function selectEndpointMode(mode) {
            endpointMode = mode;
            document.querySelectorAll('.mode-option').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            const description = document.getElementById('modeDescription');
            if (mode === 'or') {
                description.textContent = 'Choose best endpoint to finish';
            } else {
                description.textContent = 'Visit all endpoints (Obligatory teleport after each)';
            }
        }
        
        function updateEndpointModeVisibility() {
            const selector = document.getElementById('endpointModeSelector');
            if (markers.ends.length > 1) {
                selector.style.display = 'flex';
            } else {
                selector.style.display = 'none';
            }
        }
        
        function toggleResults() {
            const content = document.getElementById('resultsContent');
            const icon = document.getElementById('toggleIcon');
            content.classList.toggle('expanded');
            icon.classList.toggle('expanded');
        }
        
        function loadImageFromUrl() {
            const url = document.getElementById('imageUrl').value.trim();
            if (!url) { alert('Please enter an image URL'); return; }
            const image = new Image();
            image.crossOrigin = "anonymous";
            image.onload = () => { img = image; initCanvas(); };
            image.onerror = () => { alert('Failed to load image. Please check the URL.'); };
            image.src = url;
        }
        
        function loadImageFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => { img = image; initCanvas(); };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function initCanvas() {
            markers = { start: null, ends: [], Markers: [], Waypoints: [] };
            optimalRoute = [];
            previewRoute = [];
            allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            updateEndpointModeVisibility();
            
            const container = document.getElementById('canvasContainer');
            container.innerHTML = '';
            markerElements = [];
            
            canvas = document.createElement('canvas');
            const maxWidth = container.clientWidth - 20;
            const maxHeight = 600;
            let width = img.width;
            let height = img.height;
            
            if (width > maxWidth) {
                height = (maxWidth / width) * height;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (maxHeight / height) * width;
                height = maxHeight;
            }
            
            canvas.width = width;
            canvas.height = height;
            ctx = canvas.getContext('2d');
            container.appendChild(canvas);
            drawCanvas();
            canvas.addEventListener('click', handleCanvasClick);
        }
        
        function drawCanvas() {
            if (!ctx || !img) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            markers.Waypoints.forEach(w => {
                ctx.strokeStyle = '#9f7aea';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(159, 122, 234, 0.1)';
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]);
            
            const routeToDraw = previewRoute.length > 0 ? previewRoute : optimalRoute;
            const isPreview = previewRoute.length > 0;
            
            if (WaypointDiscoveryMode && routeToDraw.length > 0) {
                const discoveredWaypoints = new Set();
                
                for (let i = 0; i < routeToDraw.length; i++) {
                    const point = routeToDraw[i];
                    updateDiscoveredWaypoints(point, discoveredWaypoints);
                    
                    if (i > 0) {
                        const prevPoint = routeToDraw[i - 1];
                        for (const Waypoint of markers.Waypoints) {
                            if (!discoveredWaypoints.has(Waypoint) && 
                                lineSegmentIntersectsCircle(prevPoint, point, Waypoint, Waypoint.radius)) {
                                discoveredWaypoints.add(Waypoint);
                            }
                        }
                    }
                }
                
                for (const Waypoint of discoveredWaypoints) {
                    ctx.strokeStyle = '#48bb78';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(Waypoint.x, Waypoint.y, Waypoint.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#48bb78';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('‚úì', Waypoint.x + Waypoint.radius + 5, Waypoint.y - Waypoint.radius);
                }
                ctx.setLineDash([]);
            }
            
            if (routeToDraw.length > 0) {
                ctx.strokeStyle = isPreview ? '#4299e1' : '#f56565';
                ctx.lineWidth = isPreview ? 3 : 4;
                ctx.setLineDash(isPreview ? [4, 4] : [8, 8]);
                ctx.globalAlpha = isPreview ? 0.7 : 0.8;
                
                for (let i = 0; i < routeToDraw.length - 1; i++) {
                    const current = routeToDraw[i];
                    const next = routeToDraw[i + 1];
                    // Skip drawing line if next is a teleport waypoint (not explicitly visited)
                    if (next.type === 'Waypoint' && !next.explicitVisit) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(next.x, next.y);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1.0;
                ctx.setLineDash([]);
                
                // Draw teleport indicators
                for (let i = 0; i < routeToDraw.length - 1; i++) {
                    const current = routeToDraw[i];
                    const next = routeToDraw[i + 1];
                    // Only show teleport indicator for waypoints that aren't explicitly visited
                    if (next.type === 'Waypoint' && !next.explicitVisit) {
                        const text = `‚ö° W${next.id + 1}`;
                        const textPos = findBestTextPosition(current, next, text, routeToDraw);
                        ctx.save();
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = isPreview ? '#4299e1' : '#9f7aea';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.strokeText(text, textPos.x, textPos.y);
                        ctx.fillText(text, textPos.x, textPos.y);
                        ctx.restore();
                    }
                }
            }
        }
        
        function findBestTextPosition(origin, Waypoint, text, route) {
            const dx = Waypoint.x - origin.x;
            const dy = Waypoint.y - origin.y;
            const angle = Math.atan2(dy, dx);
            const positions = [
                { offset: 35, angleOffset: 0 },
                { offset: 35, angleOffset: Math.PI / 2 },
                { offset: 35, angleOffset: -Math.PI / 2 },
                { offset: 35, angleOffset: Math.PI },
                { offset: 50, angleOffset: Math.PI / 4 },
                { offset: 50, angleOffset: -Math.PI / 4 },
                { offset: 50, angleOffset: 3 * Math.PI / 4 },
                { offset: 50, angleOffset: -3 * Math.PI / 4 },
            ];
            ctx.font = 'bold 14px Arial';
            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.width;
            const allMarkers = [markers.start, ...markers.ends, ...markers.Markers, ...markers.Waypoints, ...route].filter(m => m);
            
            for (const pos of positions) {
                const testAngle = angle + pos.angleOffset;
                const testX = origin.x + Math.cos(testAngle) * pos.offset;
                const testY = origin.y + Math.sin(testAngle) * pos.offset;
                let hasCollision = false;
                const markerRadius = 20;
                
                for (const marker of allMarkers) {
                    const dist = Math.sqrt(Math.pow(testX - marker.x, 2) + Math.pow(testY - marker.y, 2));
                    if (dist < markerRadius + textWidth / 2) { hasCollision = true; break; }
                }
                if (!hasCollision) return { x: testX, y: testY };
            }
            return { x: origin.x + Math.cos(angle) * 60, y: origin.y + Math.sin(angle) * 60 };
        }
        
        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (selectedMarkerType === 'start') {
                if (markers.start) removeMarker('start', null);
                markers.start = { x, y, type: 'start' };
                createMarkerElement('start', x, y);
            } else if (selectedMarkerType === 'end') {
                const id = markers.ends.length;
                markers.ends.push({ x, y, id, type: 'end' });
                createMarkerElement('end', x, y, id);
                updateEndpointModeVisibility();
            } else if (selectedMarkerType === 'Marker') {
                const id = markers.Markers.length;
                markers.Markers.push({ x, y, id, type: 'Marker' });
                createMarkerElement('Marker', x, y, id);
            } else if (selectedMarkerType === 'Waypoint') {
                const id = markers.Waypoints.length;
                markers.Waypoints.push({ x, y, id, type: 'Waypoint', radius: 30 });
                createMarkerElement('Waypoint', x, y, id);
                drawCanvas();
            }
        }
        
        function onWaypointResize(e) {
            if (!resizingWaypoint) return;
            isDraggingRadius = true;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const dist = Math.sqrt(Math.pow(mouseX - resizingWaypoint.x, 2) + Math.pow(mouseY - resizingWaypoint.y, 2));
            resizingWaypoint.radius = Math.max(15, dist);
            
            drawCanvas();
        }
        
        function onWaypointResizeEnd() {
            resizingWaypoint = null;
            document.removeEventListener('mousemove', onWaypointResize);
            document.removeEventListener('mouseup', onWaypointResizeEnd);
            setTimeout(() => { isDraggingRadius = false; }, 50);
        }

        function createMarkerElement(type, x, y, id = null) {
            const container = document.getElementById('canvasContainer');
            const rect = canvas.getBoundingClientRect();
            const marker = document.createElement('div');
            marker.className = `marker ${type}`;
            marker.style.left = (rect.left - container.getBoundingClientRect().left + x) + 'px';
            marker.style.top = (rect.top - container.getBoundingClientRect().top + y) + 'px';
            marker.dataset.type = type;
            
            if (type === 'Marker') { marker.dataset.id = id; marker.textContent = id + 1; }
            else if (type === 'Waypoint') { 
                marker.dataset.id = id; 
                marker.textContent = 'W' + (id + 1); 
                
                marker.addEventListener('mousedown', function(e) {
                    if (e.button !== 0) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizingWaypoint = markers.Waypoints.find(w => w.id === id);
                    isDraggingRadius = false;
                    
                    document.addEventListener('mousemove', onWaypointResize);
                    document.addEventListener('mouseup', onWaypointResizeEnd);
                });
            }
            else if (type === 'end') { marker.dataset.id = id; marker.textContent = 'E' + (id + 1); }
            
            marker.addEventListener('click', function(e) {
                e.stopPropagation();
                if (type === 'Waypoint' && isDraggingRadius) {
                    return;
                }
                removeMarker(type, id);
            });
            container.appendChild(marker);
            markerElements.push(marker);
        }
        
        function removeMarker(type, id = null) {
            const container = document.getElementById('canvasContainer');
            if (type === 'start') {
                markers.start = null;
                const element = container.querySelector('.marker.start');
                if (element) element.remove();
            } else if (type === 'end') {
                const idx = markers.ends.findIndex(e => e.id === id);
                if (idx !== -1) {
                    markers.ends.splice(idx, 1);
                    container.querySelectorAll('.marker.end').forEach(el => el.remove());
                    markers.ends.forEach((e, i) => { e.id = i; createMarkerElement('end', e.x, e.y, i); });
                }
                updateEndpointModeVisibility();
            } else if (type === 'Marker') {
                const idx = markers.Markers.findIndex(w => w.id === id);
                if (idx !== -1) {
                    markers.Markers.splice(idx, 1);
                    container.querySelectorAll('.marker.Marker').forEach(el => el.remove());
                    markers.Markers.forEach((w, i) => { w.id = i; createMarkerElement('Marker', w.x, w.y, i); });
                }
            } else if (type === 'Waypoint') {
                const idx = markers.Waypoints.findIndex(w => w.id === id);
                if (idx !== -1) {
                    markers.Waypoints.splice(idx, 1);
                    container.querySelectorAll('.marker.Waypoint').forEach(el => el.remove());
                    markers.Waypoints.forEach((w, i) => { w.id = i; createMarkerElement('Waypoint', w.x, w.y, i); });
                }
            }
            optimalRoute = []; previewRoute = []; allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            drawCanvas();
        }
        
        function clearAll() {
            const container = document.getElementById('canvasContainer');
            container.querySelectorAll('.marker').forEach(m => m.remove());
            markers = { start: null, ends: [], Markers: [], Waypoints: [] };
            markerElements = []; optimalRoute = []; previewRoute = []; allResults = [];
            document.getElementById('resultsPanel').classList.remove('active');
            updateEndpointModeVisibility();
            if (img) drawCanvas();
        }
        
        let distanceCache = new Map();
        function clearDistanceCache() { distanceCache.clear(); }
        
        function calculatePath() {
            if (!markers.start) { alert('Please set a start point'); return; }
            if (endpointMode === 'and' && markers.ends.length > 0 && markers.Waypoints.length === 0) {
                alert('AND mode requires at least one Waypoint to handle mandatory teleportation from endpoints!');
                return;
            }
            if (markers.Markers.length > 25 && !confirm(`You have ${markers.Markers.length} Markers. Continue?`)) return;
            
            clearDistanceCache();
            const resultsPanel = document.getElementById('resultsPanel');
            const resultsContent = document.getElementById('resultsContent');
            resultsPanel.classList.add('active');
            resultsContent.innerHTML = '<div class="computing"><div class="computing-spinner">‚öôÔ∏è</div><p>Computing routes...</p></div>';
            
            setTimeout(() => {
                try {
                    const results = runAllAlgorithms();
                    displayResults(results);
                    if (!resultsContent.classList.contains('expanded')) toggleResults();
                } catch (error) {
                    console.error('Error computing routes:', error);
                    resultsContent.innerHTML = '<div class="computing"><p style="color: #f56565;">Error computing routes.</p></div>';
                }
            }, 100);
        }
        
        function runAllAlgorithms() {
            const start = markers.start;
            const Markers = markers.Markers;
            let scenarios = [];
            
            if (endpointMode === 'or' && markers.ends.length > 0) {
                markers.ends.forEach(end => {
                    scenarios.push({ destination: end, pointsToVisit: [...Markers] });
                });
            } else if (endpointMode === 'and') {
                scenarios.push({ destination: null, pointsToVisit: [...Markers, ...markers.ends] });
            } else {
                scenarios.push({ destination: markers.ends.length > 0 ? markers.ends[0] : null, pointsToVisit: [...Markers] });
            }

            const runAlgorithm = (algoName, algoFunc) => {
                let bestForAlgo = null;
                let minAlgoDist = Infinity;
                scenarios.forEach(scenario => {
                    const rawPath = algoFunc(start, scenario.destination, scenario.pointsToVisit);
                    const processedPath = insertWaypointsInPath(rawPath);
                    const dist = calculatePathDistance(processedPath);
                    if (dist < minAlgoDist) {
                        minAlgoDist = dist;
                        bestForAlgo = { name: algoName, path: processedPath, distance: dist };
                    }
                });
                return bestForAlgo;
            };

            const results = [];
            const pointCount = Math.max(...scenarios.map(s => s.pointsToVisit.length));

            if (pointCount <= 7) results.push(runAlgorithm('Brute Force (Optimal)', bruteForceAllPoints));
            results.push(runAlgorithm('Nearest Neighbor', nearestNeighborAllPoints));
            if (pointCount <= 20) {
                results.push(runAlgorithm('Nearest Neighbor + 2-Opt', (s, e, p) => twoOptImprove(nearestNeighborAllPoints(s, e, p))));
            }
            results.push(runAlgorithm('Greedy Insertion', greedyInsertion));
            const attempts = pointCount <= 10 ? 15 : pointCount <= 15 ? 10 : 5;
            results.push(runAlgorithm(`Random Restart (${attempts}x)`, (s, e, p) => randomRestart(s, e, p, attempts)));
            
            return results;
        }
        
        function bruteForceAllPoints(start, end, points) {
            if (points.length === 0) return end ? [start, end] : [start];
            let bestPath = null, bestDist = Infinity, permCount = 0;
            const maxPerms = 50000;
            
            function permute(remaining, currentPath) {
                if (++permCount > maxPerms) return;
                if (remaining.length === 0) {
                    const fullPath = end ? [...currentPath, end] : currentPath;
                    const dist = calculatePathDistance(fullPath);
                    if (dist < bestDist) { bestDist = dist; bestPath = fullPath; }
                    return;
                }
                for (let i = 0; i < remaining.length; i++) {
                    const next = remaining[i];
                    permute(remaining.filter((_, idx) => idx !== i), [...currentPath, next]);
                }
            }
            permute(points, [start]);
            return bestPath || [start, ...(end ? [end] : [])];
        }
        
        function nearestNeighborAllPoints(start, end, points) {
            if (points.length === 0) return end ? [start, end] : [start];
            const path = [start];
            let current = start;
            const remaining = new Set(points);
            const discoveredWaypoints = new Set();
            updateDiscoveredWaypoints(current, discoveredWaypoints);
            
            while (remaining.size > 0) {
                let nearest = null, minDist = Infinity;
                let bestWaypointDetour = null;
                
                // Find nearest point considering both direct paths and waypoint detours
                for (const point of remaining) {
                    const directDist = distanceWithDiscovery(current, point, discoveredWaypoints);
                    
                    // Check if detouring through an undiscovered waypoint would be better
                    if (WaypointDiscoveryMode) {
                        for (const waypoint of markers.Waypoints) {
                            if (!isWaypointDiscovered(waypoint, discoveredWaypoints)) {
                                // Cost: walk to waypoint + walk from waypoint to point
                                const detourDist = euclideanDistance(current, waypoint) + euclideanDistance(waypoint, point);
                                
                                // Estimate future savings from having this waypoint
                                const futureSavings = estimateWaypointValue(waypoint, remaining, discoveredWaypoints);
                                
                                // Only detour if: detour_cost + (future_savings / remaining_count) < direct_cost
                                // We divide future savings by remaining count to amortize benefit
                                const effectiveCost = detourDist - (futureSavings / remaining.size);
                                
                                if (effectiveCost < directDist && effectiveCost < minDist) {
                                    minDist = effectiveCost;
                                    nearest = point;
                                    bestWaypointDetour = waypoint;
                                }
                            }
                        }
                    }
                    
                    // Compare with direct path
                    if (directDist < minDist) {
                        minDist = directDist;
                        nearest = point;
                        bestWaypointDetour = null;
                    }
                }
                
                if (nearest) {
                    // If we found a beneficial waypoint detour, visit it first
                    if (bestWaypointDetour) {
                        const waypointCopy = { ...bestWaypointDetour, explicitVisit: true };
                        path.push(waypointCopy);
                        current = waypointCopy;
                        updateDiscoveredWaypoints(current, discoveredWaypoints);
                    }
                    
                    updateDiscoveriesAlongSegment(current, nearest, discoveredWaypoints);
                    path.push(nearest);
                    current = nearest;
                    updateDiscoveredWaypoints(current, discoveredWaypoints);
                    remaining.delete(nearest);
                }
            }
            if (end) path.push(end);
            return path;
        }
        
        function twoOptImprove(path) {
            if (path.length < 4) return path;
            let improved = true, bestPath = [...path], iterations = 0;
            const maxIterations = Math.min(50, path.length * 2);
            
            while (improved && iterations < maxIterations) {
                improved = false; iterations++;
                for (let i = 1; i < bestPath.length - 2; i++) {
                    for (let j = i + 1; j < bestPath.length - 1; j++) {
                        const currentCost = calculatePathDistance(bestPath);
                        const newPath = [...bestPath];
                        newPath.splice(i, j - i + 1, ...newPath.slice(i, j + 1).reverse());
                        const newCost = calculatePathDistance(newPath);
                        
                        if (newCost < currentCost) {
                            bestPath = newPath; improved = true;
                        }
                    }
                }
            }
            return bestPath;
        }
        
        function greedyInsertion(start, end, points) {
            if (points.length === 0) return end ? [start, end] : [start];
            const path = [start, points[0]];
            if (end) path.push(end);
            const remaining = new Set(points.slice(1));
            const discoveredWaypoints = new Set();
            updateDiscoveredWaypoints(start, discoveredWaypoints);
            updateDiscoveriesAlongSegment(start, points[0], discoveredWaypoints);
            updateDiscoveredWaypoints(points[0], discoveredWaypoints);
            let totalChecks = 0;
            const MAX_CHECKS = 10000;
            
            while (remaining.size > 0) {
                let bestPoint = null, bestPosition = -1, bestIncrease = Infinity;
                let bestWaypointDetour = null, bestWaypointPosition = -1;
                
                for (const point of remaining) {
                    const maxPos = end ? path.length - 1 : path.length;
                    for (let i = 1; i < maxPos; i++) {
                        totalChecks++;
                        if (totalChecks > MAX_CHECKS) {
                            const insertPos = end ? path.length - 1 : path.length;
                            Array.from(remaining).forEach(p => path.splice(insertPos, 0, p));
                            return path;
                        }
                        const before = path[i - 1], after = path[i];
                        const currentDist = distanceWithDiscovery(before, after, discoveredWaypoints);
                        const newDist = distanceWithDiscovery(before, point, discoveredWaypoints) + 
                                      distanceWithDiscovery(point, after, discoveredWaypoints);
                        const increase = newDist - currentDist;
                        
                        // Check waypoint detour option for this insertion
                        if (WaypointDiscoveryMode) {
                            for (const waypoint of markers.Waypoints) {
                                if (!isWaypointDiscovered(waypoint, discoveredWaypoints)) {
                                    const detourDist = euclideanDistance(before, waypoint) + 
                                                      euclideanDistance(waypoint, point) + 
                                                      distanceWithDiscovery(point, after, discoveredWaypoints);
                                    const futureSavings = estimateWaypointValue(waypoint, remaining, discoveredWaypoints);
                                    const effectiveIncrease = (detourDist - currentDist) - (futureSavings / remaining.size);
                                    
                                    if (effectiveIncrease < bestIncrease) {
                                        bestIncrease = effectiveIncrease;
                                        bestPoint = point;
                                        bestPosition = i;
                                        bestWaypointDetour = waypoint;
                                        bestWaypointPosition = i;
                                    }
                                }
                            }
                        }
                        
                        if (increase < bestIncrease) {
                            bestIncrease = increase;
                            bestPoint = point;
                            bestPosition = i;
                            bestWaypointDetour = null;
                        }
                    }
                }
                
                if (bestPoint) {
                    // Insert waypoint detour if beneficial
                    if (bestWaypointDetour) {
                        const waypointCopy = { ...bestWaypointDetour, explicitVisit: true };
                        path.splice(bestWaypointPosition, 0, waypointCopy);
                        updateDiscoveredWaypoints(waypointCopy, discoveredWaypoints);
                        // Adjust position since we inserted waypoint
                        if (bestPosition >= bestWaypointPosition) bestPosition++;
                    }
                    
                    const before = path[bestPosition - 1];
                    updateDiscoveriesAlongSegment(before, bestPoint, discoveredWaypoints);
                    path.splice(bestPosition, 0, bestPoint);
                    updateDiscoveredWaypoints(bestPoint, discoveredWaypoints);
                    remaining.delete(bestPoint);
                } else {
                    const insertPos = end ? path.length - 1 : path.length;
                    Array.from(remaining).forEach(p => path.splice(insertPos, 0, p));
                    break;
                }
            }
            return path;
        }
        
        function randomRestart(start, end, points, attempts) {
            if (points.length === 0) return end ? [start, end] : [start];
            let bestPath = null, bestDist = Infinity;
            
            for (let attempt = 0; attempt < attempts; attempt++) {
                let attemptBestPath = null, attemptBestDist = Infinity;
                const shuffled = [...points].sort(() => Math.random() - 0.5);
                
                for (let run = 0; run < 3; run++) {
                    const path = end ? [start, ...shuffled, end] : [start, ...shuffled];
                    const improved = twoOptImprove(path);
                    const dist = calculatePathDistance(improved);
                    if (dist < attemptBestDist) { attemptBestDist = dist; attemptBestPath = improved; }
                }
                if (attemptBestDist < bestDist) { bestDist = attemptBestDist; bestPath = attemptBestPath; }
            }
            return bestPath || [start, ...(end ? [end] : [])];
        }
        
        let suppressDiscoveryLogs = false;
        
        function lineSegmentIntersectsCircle(p1, p2, center, radius) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const fx = p1.x - center.x;
            const fy = p1.y - center.y;
            
            const a = dx * dx + dy * dy;
            if (a < 0.001) return euclideanDistance(p1, center) <= radius;
            
            const b = 2 * (fx * dx + fy * dy);
            const c = (fx * fx + fy * fy) - radius * radius;
            const discriminant = b * b - 4 * a * c;
            
            if (discriminant < 0) return false;
            
            const sqrtDisc = Math.sqrt(discriminant);
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);
            
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }
        
        function updateDiscoveredWaypoints(point, discoveredWaypoints) {
            if (!WaypointDiscoveryMode) { markers.Waypoints.forEach(w => discoveredWaypoints.add(w)); return; }
            for (const Waypoint of markers.Waypoints) {
                if (euclideanDistance(point, Waypoint) <= Waypoint.radius) discoveredWaypoints.add(Waypoint);
            }
        }
        
        function updateDiscoveriesAlongSegment(p1, p2, discoveredWaypoints) {
            if (!WaypointDiscoveryMode) return;
            for (const Waypoint of markers.Waypoints) {
                if (!discoveredWaypoints.has(Waypoint) && lineSegmentIntersectsCircle(p1, p2, Waypoint, Waypoint.radius)) {
                    discoveredWaypoints.add(Waypoint);
                }
            }
        }
        
        function isWaypointDiscovered(Waypoint, discoveredWaypoints) {
            return !WaypointDiscoveryMode || discoveredWaypoints.has(Waypoint);
        }
        
        // Estimate potential distance savings if this waypoint were unlocked
        function estimateWaypointValue(waypoint, remainingPoints, discoveredWaypoints) {
            if (isWaypointDiscovered(waypoint, discoveredWaypoints)) return 0;
            
            let potentialSavings = 0;
            const pointsArray = Array.from(remainingPoints);
            
            // For each pair of remaining points, estimate if teleporting via this waypoint saves distance
            for (let i = 0; i < pointsArray.length; i++) {
                for (let j = i + 1; j < pointsArray.length; j++) {
                    const directDist = euclideanDistance(pointsArray[i], pointsArray[j]);
                    const viaWaypointDist = TELEPORT_COST + euclideanDistance(waypoint, pointsArray[j]);
                    const saving = Math.max(0, directDist - viaWaypointDist);
                    // Conservative discount since not all pairs will be in sequence
                    potentialSavings += saving * 0.2;
                }
            }
            
            return potentialSavings;
        }
        
        function distanceWithDiscovery(p1, p2, discoveredWaypoints) {
            // If p1 is a waypoint (teleport source), distance to next point is just euclidean
            if (p1.type === 'Waypoint') return euclideanDistance(p1, p2);

            let bestDist = euclideanDistance(p1, p2);
            if (endpointMode === 'and' && p1.type === 'end' && markers.Waypoints.length > 0) {
                bestDist = Infinity;
            }
            
            // If p2 is an explicitly visited waypoint (walked to for discovery), treat as walk destination
            if (p2.type === 'Waypoint' && p2.explicitVisit) {
                return euclideanDistance(p1, p2);
            }
            
            // If p2 is a waypoint teleport point, check if discovered
            if (p2.type === 'Waypoint') {
                return isWaypointDiscovered(p2, discoveredWaypoints) ? TELEPORT_COST : 999999;
            }
            
            if (markers.Waypoints.length === 0) return bestDist;

            // Check if any discovered waypoint provides a shorter teleport route
            for (const Waypoint of markers.Waypoints) {
                if (!isWaypointDiscovered(Waypoint, discoveredWaypoints)) continue;
                const totalViaWaypoint = TELEPORT_COST + euclideanDistance(Waypoint, p2);
                if (totalViaWaypoint < bestDist) {
                    bestDist = totalViaWaypoint;
                }
            }
            return bestDist;
        }
        
        function findBestWaypoint(p1, p2, discoveredWaypoints) {
            if (p1.type === 'Waypoint' || p2.type === 'Waypoint') return null;
            
            let directDist = euclideanDistance(p1, p2);
            if (endpointMode === 'and' && p1.type === 'end' && markers.Waypoints.length > 0) {
                directDist = Infinity;
            }
            
            let bestWaypoint = null;
            let bestDist = directDist;
            
            for (const Waypoint of markers.Waypoints) {
                if (!isWaypointDiscovered(Waypoint, discoveredWaypoints)) continue;
                const WaypointPath = TELEPORT_COST + euclideanDistance(Waypoint, p2);
                if (WaypointPath < bestDist) {
                    bestDist = WaypointPath;
                    bestWaypoint = Waypoint;
                }
            }
            return bestWaypoint;
        }
        
        function insertWaypointsInPath(path) {
            const discoveredWaypoints = new Set();
            if (!WaypointDiscoveryMode) markers.Waypoints.forEach(w => discoveredWaypoints.add(w));
            
            const newPath = [path[0]];
            updateDiscoveredWaypoints(path[0], discoveredWaypoints);
            
            for (let i = 1; i < path.length; i++) {
                const prev = path[i - 1];
                const current = path[i];
                
                updateDiscoveriesAlongSegment(prev, current, discoveredWaypoints);
                
                // If current is a waypoint with explicitVisit flag, it was walked to (not a teleport)
                // So add it to the path as a regular destination, not a teleport shortcut
                if (current.type === 'Waypoint' && current.explicitVisit) {
                    newPath.push(current);
                    updateDiscoveredWaypoints(current, discoveredWaypoints);
                    continue;
                }
                
                // Check if we should insert a waypoint as a teleport shortcut
                const Waypoint = findBestWaypoint(prev, current, discoveredWaypoints);
                
                if (Waypoint) {
                    newPath.push(Waypoint);
                    updateDiscoveredWaypoints(Waypoint, discoveredWaypoints);
                }
                newPath.push(current);
                updateDiscoveredWaypoints(current, discoveredWaypoints);
            }
            return newPath;
        }
        
        function euclideanDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        
        function displayResults(results) {
            const resultsContent = document.getElementById('resultsContent');
            allResults = results;
            const bestResult = results.reduce((best, current) => current.distance < best.distance ? current : best);
            optimalRoute = bestResult.path;
            previewRoute = [];
            drawCanvas();
            
            let html = '';
            results.forEach((result, index) => {
                const isBest = result === bestResult;
                const routeStr = formatRoute(result.path);
                html += `
                    <div class="method-result ${isBest ? 'best' : ''}" 
                         data-result-index="${index}"
                         onmouseenter="previewResult(${index})"
                         onmouseleave="clearPreview()">
                        <div class="method-name">
                            <span>${result.name}</span>
                            ${isBest ? '<span class="badge">BEST</span>' : ''}
                        </div>
                        <div class="method-distance">${result.distance.toFixed(2)} pixels</div>
                        <div class="method-route">${routeStr}</div>
                    </div>`;
            });
            resultsContent.innerHTML = html;
        }
        
        function previewResult(index) { if (allResults[index]) { previewRoute = allResults[index].path; drawCanvas(); } }
        function clearPreview() { previewRoute = []; drawCanvas(); }
        
        function formatRoute(path) {
            return path.map(point => {
                if (point.type === 'start') return 'Start';
                if (point.type === 'end') return `E${point.id + 1}`;
                if (point.type === 'Waypoint') {
                    // Mark explicitly visited waypoints with walk icon
                    return point.explicitVisit ? `üö∂W${point.id + 1}` : `‚ö°W${point.id + 1}`;
                }
                return `P${point.id + 1}`;
            }).join(' ‚Üí ');
        }
        
        function calculatePathDistance(path) {
            if (!path || path.length < 2) return 0;
            suppressDiscoveryLogs = true;
            let total = 0;
            const discoveredWaypoints = new Set();
            if (!WaypointDiscoveryMode) markers.Waypoints.forEach(w => discoveredWaypoints.add(w));
            
            for (let i = 0; i < path.length - 1; i++) {
                const current = path[i];
                const next = path[i + 1];
                updateDiscoveredWaypoints(current, discoveredWaypoints);
                updateDiscoveriesAlongSegment(current, next, discoveredWaypoints);
                total += distanceWithDiscovery(current, next, discoveredWaypoints);
            }
            suppressDiscoveryLogs = false;
            return total;
        }
    </script>
</body>
</html>
